
AVRASM ver. 2.1.52  iris.asm Sat Aug 16 18:32:47 2014

iris.asm(10): Including file '../../core\macros.asm'
../../core\macros.asm(16): Including file '../../core\user.inc'
iris.asm(14): Including file '../../core/devices/atmega1281\device.asm'
../../core/devices/atmega1281\device.asm(5): Including file '../../Atmel/Appnotes2\m1281def.inc'
iris.asm(43): Including file '../../core\drivers/usart_0.asm'
../../core\drivers/usart_0.asm(32): Including file '../../core\drivers/usart_common.asm'
../../core\drivers/usart_common.asm(5): Including file '../../core\drivers/usart-isr-rx.asm'
../../core\drivers/usart_common.asm(6): Including file '../../core\words/usart-rx-isr.asm'
../../core\drivers/usart_common.asm(25): Including file '../../core\words/usart-tx-poll.asm'
../../core\drivers/usart_common.asm(28): warning: Use of undefined or forward referenced symbol 'XT_NOOP' in .equ/.set
../../core\drivers/usart_common.asm(31): Including file '../../core\words/ubrr.asm'
../../core\drivers/usart_common.asm(32): Including file '../../core\words/usart.asm'
iris.asm(58): Including file 'words/IRIS1wire.asm'
iris.asm(64): Including file '../../core\amforth.asm'
../../core\amforth.asm(9): Including file '../../core\drivers/generic-isr.asm'
../../core\amforth.asm(11): Including file 'dict_appl.inc'
dict_appl.inc(3): Including file '../../core\dict_minimum.inc'
../../core\dict_minimum.inc(2): Including file '../../core\words/f_cpu.asm'
../../core\dict_minimum.inc(3): Including file '../../core\words/state.asm'
../../core\dict_minimum.inc(4): Including file '../../core\words/base.asm'
../../core\dict_minimum.inc(6): Including file '../../core\words/cells.asm'
../../core\dict_minimum.inc(7): Including file '../../core\words/cellplus.asm'
../../core\dict_minimum.inc(9): Including file '../../core\words/g_in.asm'
../../core\dict_minimum.inc(10): Including file '../../core\words/sharptib.asm'
../../core\dict_minimum.inc(11): Including file '../../core\words/pad.asm'
../../core\dict_minimum.inc(12): Including file '../../core\words/emit.asm'
../../core\dict_minimum.inc(13): Including file '../../core\words/emitq.asm'
../../core\dict_minimum.inc(14): Including file '../../core\words/key.asm'
../../core\dict_minimum.inc(15): Including file '../../core\words/keyq.asm'
../../core\dict_minimum.inc(17): Including file '../../core\words/dp.asm'
../../core\dict_minimum.inc(18): Including file '../../core\words/edp.asm'
../../core\dict_minimum.inc(19): Including file '../../core\words/here.asm'
../../core\dict_minimum.inc(20): Including file '../../core\words/allot.asm'
../../core\dict_minimum.inc(22): Including file '../../core\words/docreate.asm'
../../core\dict_minimum.inc(23): Including file '../../core\words/backslash.asm'
../../core\dict_minimum.inc(24): Including file '../../core\words/lparenthesis.asm'
../../core\dict_minimum.inc(26): Including file '../../core\words/compile.asm'
../../core\dict_minimum.inc(27): Including file '../../core\words/comma.asm'
../../core\dict_minimum.inc(28): Including file '../../core\words/brackettick.asm'
../../core\dict_minimum.inc(30): Including file '../../core\words/bin.asm'
../../core\dict_minimum.inc(31): Including file '../../core\words/decimal.asm'
../../core\dict_minimum.inc(32): Including file '../../core\words/hex.asm'
../../core\dict_minimum.inc(33): Including file '../../core\words/bl.asm'
../../core\dict_minimum.inc(35): Including file '../../core\words/turnkey.asm'
../../core\dict_minimum.inc(37): Including file '../../core\words/starslashmod.asm'
../../core\dict_minimum.inc(38): Including file '../../core\words/slashmod.asm'
../../core\dict_minimum.inc(39): Including file '../../core\words/starslash.asm'
../../core\dict_minimum.inc(40): Including file '../../core\words/uslashmod.asm'
../../core\dict_minimum.inc(41): Including file '../../core\words/negate.asm'
../../core\dict_minimum.inc(42): Including file '../../core\words/slash.asm'
../../core\dict_minimum.inc(43): Including file '../../core\words/mod.asm'
../../core\dict_minimum.inc(44): Including file '../../core\words/abs.asm'
../../core\dict_minimum.inc(45): Including file '../../core\words/min.asm'
../../core\dict_minimum.inc(46): Including file '../../core\words/max.asm'
../../core\dict_minimum.inc(47): Including file '../../core\words/within.asm'
../../core\dict_minimum.inc(49): Including file '../../core\words/to-upper.asm'
../../core\dict_minimum.inc(50): Including file '../../core\words/to-lower.asm'
../../core\dict_minimum.inc(52): Including file '../../core\words/hld.asm'
../../core\dict_minimum.inc(53): Including file '../../core\words/hold.asm'
../../core\dict_minimum.inc(54): Including file '../../core\words/l_sharp.asm'
../../core\dict_minimum.inc(55): Including file '../../core\words/sharp.asm'
../../core\dict_minimum.inc(56): Including file '../../core\words/sharp_s.asm'
../../core\dict_minimum.inc(57): Including file '../../core\words/sharp_g.asm'
../../core\dict_minimum.inc(58): Including file '../../core\words/sign.asm'
../../core\dict_minimum.inc(59): Including file '../../core\words/ddotr.asm'
../../core\dict_minimum.inc(60): Including file '../../core\words/dotr.asm'
../../core\dict_minimum.inc(61): Including file '../../core\words/ddot.asm'
../../core\dict_minimum.inc(62): Including file '../../core\words/dot.asm'
../../core\dict_minimum.inc(63): Including file '../../core\words/uddot.asm'
../../core\dict_minimum.inc(64): Including file '../../core\words/uddotr.asm'
../../core\dict_minimum.inc(65): Including file '../../core\words/udslashmod.asm'
../../core\dict_minimum.inc(66): Including file '../../core\words/digitq.asm'
../../core\dict_minimum.inc(68): Including file '../../core\words/do-sliteral.asm'
../../core\dict_minimum.inc(69): Including file '../../core\words/scomma.asm'
../../core\dict_minimum.inc(70): Including file '../../core\words/itype.asm'
../../core\dict_minimum.inc(71): Including file '../../core\words/icount.asm'
../../core\dict_minimum.inc(72): Including file '../../core\words/cr.asm'
../../core\dict_minimum.inc(73): Including file '../../core\words/space.asm'
../../core\dict_minimum.inc(74): Including file '../../core\words/spaces.asm'
../../core\dict_minimum.inc(75): Including file '../../core\words/type.asm'
../../core\dict_minimum.inc(76): Including file '../../core\words/tick.asm'
../../core\dict_minimum.inc(78): Including file '../../core\words/handler.asm'
../../core\dict_minimum.inc(79): Including file '../../core\words/catch.asm'
../../core\dict_minimum.inc(80): Including file '../../core\words/throw.asm'
../../core\dict_minimum.inc(82): Including file '../../core\words/char-skip.asm'
../../core\dict_minimum.inc(83): Including file '../../core\words/accept.asm'
../../core\dict_minimum.inc(84): Including file '../../core\words/refill.asm'
../../core\dict_minimum.inc(85): Including file '../../core\words/char.asm'
../../core\dict_minimum.inc(86): Including file '../../core\words/number.asm'
../../core\dict_minimum.inc(87): Including file '../../core\words/to-number.asm'
../../core\dict_minimum.inc(88): Including file '../../core\words/parse.asm'
../../core\dict_minimum.inc(89): Including file '../../core\words/char-scan.asm'
../../core\dict_minimum.inc(90): Including file '../../core\words/source.asm'
../../core\dict_minimum.inc(91): Including file '../../core\words/slashstring.asm'
../../core\dict_minimum.inc(92): Including file '../../core\words/parse-name.asm'
../../core\dict_minimum.inc(93): Including file '../../core\words/find-name.asm'
../../core\dict_minimum.inc(95): Including file '../../core\words/quit.asm'
../../core\dict_minimum.inc(96): Including file '../../core\words/prompts.asm'
../../core\dict_minimum.inc(97): Including file '../../core\words/pause.asm'
../../core\dict_minimum.inc(98): Including file '../../core\words/cold.asm'
../../core\dict_minimum.inc(99): Including file '../../core\words/warm.asm'
../../core\dict_minimum.inc(101): Including file '../../core\words/sp0.asm'
../../core\dict_minimum.inc(102): Including file '../../core\words/rp0.asm'
../../core\dict_minimum.inc(103): Including file '../../core\words/depth.asm'
../../core\dict_minimum.inc(104): Including file '../../core\words/interpret.asm'
../../core\dict_minimum.inc(105): Including file '../../core\words/rec-intnumber.asm'
../../core\dict_minimum.inc(106): Including file '../../core\words/rec-find.asm'
../../core\dict_minimum.inc(107): Including file '../../core\words/rec-notfound.asm'
../../core\dict_minimum.inc(109): Including file '../../core\words/qstack.asm'
../../core\dict_minimum.inc(110): Including file '../../core\words/ver.asm'
../../core\dict_minimum.inc(112): Including file '../../core\words/noop.asm'
../../core\dict_minimum.inc(113): Including file '../../core\words/unused.asm'
../../core\dict_minimum.inc(115): Including file '../../core\words/value.asm'
../../core\dict_minimum.inc(116): Including file '../../core\words/to.asm'
../../core\dict_minimum.inc(118): Including file '../../core\words/edefer-fetch.asm'
../../core\dict_minimum.inc(119): Including file '../../core\words/edefer-store.asm'
../../core\dict_minimum.inc(120): Including file '../../core\words/rdefer-fetch.asm'
../../core\dict_minimum.inc(121): Including file '../../core\words/rdefer-store.asm'
../../core\dict_minimum.inc(122): Including file '../../core\words/udefer-fetch.asm'
../../core\dict_minimum.inc(123): Including file '../../core\words/udefer-store.asm'
../../core\dict_minimum.inc(124): Including file '../../core\words/defer-store.asm'
../../core\dict_minimum.inc(125): Including file '../../core\words/defer-fetch.asm'
../../core\dict_minimum.inc(126): Including file '../../core\words/do-defer.asm'
../../core\dict_minimum.inc(128): Including file '../../core\words/search-wordlist.asm'
../../core\dict_minimum.inc(129): Including file '../../core\words/icompare.asm'
../../core\dict_minimum.inc(131): Including file '../../core\words/star.asm'
../../core\dict_minimum.inc(132): Including file '../../core\words/j.asm'
../../core\dict_minimum.inc(134): Including file '../../core\words/d_to_s.asm'
../../core\dict_minimum.inc(135): Including file '../../core\words/dabs.asm'
../../core\dict_minimum.inc(136): Including file '../../core\words/dnegate.asm'
../../core\dict_minimum.inc(137): Including file '../../core\words/cmove.asm'
../../core\dict_minimum.inc(138): Including file '../../core\words/d-2slash.asm'
../../core\dict_minimum.inc(139): Including file '../../core\words/2swap.asm'
../../core\dict_minimum.inc(141): Including file '../../core\words/tib.asm'
../../core\dict_minimum.inc(143): Including file '../../core\words/init-user.asm'
dict_appl.inc(5): Including file '../../core\words/1ms.asm'
dict_appl.inc(7): Including file '../../core\words/2literal.asm'
dict_appl.inc(8): Including file '../../core\words/2r_from.asm'
dict_appl.inc(9): Including file '../../core\words/spirw.asm'
dict_appl.inc(10): Including file '../../core\words/2spirw.asm'
dict_appl.inc(12): Including file '../../core\words/2to_r.asm'
dict_appl.inc(15): Including file '../../core\words/bm_clear.asm'
dict_appl.inc(16): Including file '../../core\words/bm_set.asm'
dict_appl.inc(17): Including file '../../core\words/bm_toggle.asm'
dict_appl.inc(18): Including file '../../core\words/bracketcompile.asm'
dict_appl.inc(19): Including file '../../core\words/built.asm'
dict_appl.inc(20): Including file '../../core\words/count.asm'
dict_appl.inc(21): Including file '../../core\words/d-equal.asm'
dict_appl.inc(23): Including file '../../core\words/do2literal.asm'
dict_appl.inc(29): Including file '../../core\words/fill.asm'
dict_appl.inc(30): Including file '../../core\words/find.asm'
dict_appl.inc(31): Including file '../../core\words/get-recognizer.asm'
dict_appl.inc(32): Including file '../../core\words/int-num.asm'
dict_appl.inc(33): Including file '../../core\words/ms.asm'
dict_appl.inc(34): Including file '../../core\words/n_r_from.asm'
dict_appl.inc(35): Including file '../../core\words/n_to_r.asm'
dict_appl.inc(36): Including file '../../core\words/nip.asm'
dict_appl.inc(37): Including file '../../core\words/no-jtag.asm'
dict_appl.inc(38): Including file '../../core\words/notequalzero.asm'
dict_appl.inc(39): Including file '../../core\words/pick.asm'
dict_appl.inc(40): Including file '../../core\words/place.asm'
dict_appl.inc(41): Including file '../../core\words/popcnt.asm'
dict_appl.inc(42): Including file '../../core\words/reg-a.asm'
dict_appl.inc(43): Including file '../../core\words/reg-b.asm'
dict_appl.inc(44): Including file '../../core\words/set-recognizer.asm'
dict_appl.inc(45): Including file '../../core\words/d-2star.asm'
dict_appl.inc(46): Including file '../../core\words/d-plus.asm'
dict_appl.inc(47): Including file '../../core\words/d-minus.asm'
dict_appl.inc(48): Including file '../../core\words/d-invert.asm'
dict_appl.inc(49): Including file '../../core\words/udot.asm'
dict_appl.inc(50): Including file '../../core\words/dot-s.asm'
dict_appl.inc(51): Including file '../../core\words/udotr.asm'
dict_appl.inc(52): Including file '../../core\words/uzerodotr.asm'
dict_appl.inc(53): Including file '../../core\words/dotstring.asm'
dict_appl.inc(54): Including file '../../core\words/squote.asm'
dict_appl.inc(55): Including file '../../core\words/wdr.asm'
dict_appl.inc(56): Including file '../../core\words/words.asm'
dict_appl.inc(57): Including file '../../core\words/word.asm'
dict_appl.inc(58): Including file '../../core\words/edefer.asm'
dict_appl.inc(59): Including file '../../core\words/rdefer.asm'
dict_appl.inc(60): Including file '../../core\words/is.asm'
dict_appl.inc(61): Including file '../../core\dict_compiler.inc'
../../core\dict_compiler.inc(1): Including file '../../core\words/literal.asm'
../../core\dict_compiler.inc(2): Including file '../../core\words/sliteral.asm'
../../core\dict_compiler.inc(3): Including file '../../core\words/g_mark.asm'
../../core\dict_compiler.inc(4): Including file '../../core\words/g_resolve.asm'
../../core\dict_compiler.inc(5): Including file '../../core\words/l_mark.asm'
../../core\dict_compiler.inc(6): Including file '../../core\words/l_resolve.asm'
../../core\dict_compiler.inc(9): Including file '../../core\words/ahead.asm'
../../core\dict_compiler.inc(10): Including file '../../core\words/if.asm'
../../core\dict_compiler.inc(11): Including file '../../core\words/else.asm'
../../core\dict_compiler.inc(12): Including file '../../core\words/then.asm'
../../core\dict_compiler.inc(13): Including file '../../core\words/begin.asm'
../../core\dict_compiler.inc(14): Including file '../../core\words/while.asm'
../../core\dict_compiler.inc(15): Including file '../../core\words/repeat.asm'
../../core\dict_compiler.inc(16): Including file '../../core\words/until.asm'
../../core\dict_compiler.inc(17): Including file '../../core\words/again.asm'
../../core\dict_compiler.inc(18): Including file '../../core\words/do.asm'
../../core\dict_compiler.inc(19): Including file '../../core\words/loop.asm'
../../core\dict_compiler.inc(20): Including file '../../core\words/plusloop.asm'
../../core\dict_compiler.inc(21): Including file '../../core\words/leave.asm'
../../core\dict_compiler.inc(22): Including file '../../core\words/qdo.asm'
../../core\dict_compiler.inc(25): Including file '../../core\words/create.asm'
../../core\dict_compiler.inc(26): Including file '../../core\words/header.asm'
../../core\dict_compiler.inc(27): Including file '../../core\words/reveal.asm'
../../core\dict_compiler.inc(28): Including file '../../core\words/latest.asm'
../../core\dict_compiler.inc(29): Including file '../../core\words/does.asm'
../../core\dict_compiler.inc(30): Including file '../../core\words/colon.asm'
../../core\dict_compiler.inc(31): Including file '../../core\words/colon-noname.asm'
../../core\dict_compiler.inc(32): Including file '../../core\words/semicolon.asm'
../../core\dict_compiler.inc(33): Including file '../../core\words/rightbracket.asm'
../../core\dict_compiler.inc(34): Including file '../../core\words/leftbracket.asm'
../../core\dict_compiler.inc(35): Including file '../../core\words/variable.asm'
../../core\dict_compiler.inc(36): Including file '../../core\words/constant.asm'
../../core\dict_compiler.inc(37): Including file '../../core\words/user.asm'
../../core\dict_compiler.inc(39): Including file '../../core\words/recurse.asm'
../../core\dict_compiler.inc(40): Including file '../../core\words/immediate.asm'
../../core\dict_compiler.inc(42): Including file '../../core\words/bracketchar.asm'
../../core\dict_compiler.inc(43): Including file '../../core\words/abortstring.asm'
../../core\dict_compiler.inc(44): Including file '../../core\words/abort.asm'
../../core\dict_compiler.inc(46): Including file '../../core\words/code.asm'
../../core\dict_compiler.inc(47): Including file '../../core\words/end-code.asm'
../../core\dict_compiler.inc(49): Including file '../../core\words/environment.asm'
../../core\dict_compiler.inc(50): Including file '../../core\words/env-wordlists.asm'
../../core\dict_compiler.inc(51): Including file '../../core\words/env-slashpad.asm'
../../core\dict_compiler.inc(52): Including file '../../core\words/env-slashhold.asm'
../../core\dict_compiler.inc(53): Including file '../../core\words/env-forthname.asm'
../../core\dict_compiler.inc(54): Including file '../../core\words/env-forthversion.asm'
../../core\dict_compiler.inc(55): Including file '../../core\words/env-cpu.asm'
../../core\dict_compiler.inc(56): Including file '../../core\words/env-mcuinfo.asm'
../../core\dict_compiler.inc(57): Including file '../../core\words/env-usersize.asm'
../../core\dict_compiler.inc(59): Including file '../../core\words/fetch-ee-array.asm'
../../core\dict_compiler.inc(60): Including file '../../core\words/store-ee-array.asm'
../../core\dict_compiler.inc(61): Including file '../../core\words/get-current.asm'
../../core\dict_compiler.inc(62): Including file '../../core\words/get-order.asm'
../../core\dict_compiler.inc(66): Including file '../../core\words/compare.asm'
../../core\dict_compiler.inc(67): Including file '../../core\words/nfa2lfa.asm'
dict_appl.inc(62): Including file '../../core\words/show-wordlist.asm'
dict_appl.inc(63): Including file '../../core\dict_interrupt.inc'
../../core\dict_interrupt.inc(2): Including file '../../core\words/int-on.asm'
../../core\dict_interrupt.inc(3): Including file '../../core\words/int-off.asm'
../../core\dict_interrupt.inc(4): Including file '../../core\words/int-store.asm'
../../core\dict_interrupt.inc(5): Including file '../../core\words/int-fetch.asm'
../../core\dict_interrupt.inc(6): Including file '../../core\words/int-trap.asm'
../../core\dict_interrupt.inc(8): Including file '../../core\words/isr-exec.asm'
../../core\dict_interrupt.inc(9): Including file '../../core\words/isr-end.asm'
dict_appl.inc(66): Including file '../../core/devices/atmega1281\device.inc'
dict_appl.inc(68): Including file 'words/applturnkey.asm'
dict_appl.inc(69): Including file 'words/qmark.asm'
dict_appl.inc(71): Including file '../../core\dict_wl.inc'
../../core\dict_wl.inc(2): Including file '../../core\words/set-current.asm'
../../core\dict_wl.inc(3): Including file '../../core\words/previous.asm'
../../core\dict_wl.inc(4): Including file '../../core\words/definitions.asm'
../../core\dict_wl.inc(5): Including file '../../core\words/wordlist.asm'
../../core\dict_wl.inc(7): Including file '../../core\words/only.asm'
../../core\dict_wl.inc(8): Including file '../../core\words/forth.asm'
../../core\dict_wl.inc(9): Including file '../../core\words/forth-wordlist.asm'
../../core\dict_wl.inc(10): Including file '../../core\words/also.asm'
../../core\dict_wl.inc(11): Including file '../../core\words/set-order.asm'
../../core\dict_wl.inc(12): Including file '../../core\words/order.asm'
../../core\amforth.asm(16): Including file '../../core\amforth-interpreter.asm'
../../core\amforth.asm(17): Including file 'dict_appl_core.inc'
dict_appl_core.inc(1): Including file '../../core\dict_core.inc'
../../core\dict_core.inc(4): Including file '../../core\words/exit.asm'
../../core\dict_core.inc(5): Including file '../../core\words/execute.asm'
../../core\dict_core.inc(6): Including file '../../core\words/dobranch.asm'
../../core\dict_core.inc(7): Including file '../../core\words/docondbranch.asm'
../../core\dict_core.inc(10): Including file '../../core\words/doliteral.asm'
../../core\dict_core.inc(11): Including file '../../core\words/dovariable.asm'
../../core\dict_core.inc(12): Including file '../../core\words/doconstant.asm'
../../core\dict_core.inc(13): Including file '../../core\words/douser.asm'
../../core\dict_core.inc(14): Including file '../../core\words/do-value.asm'
../../core\dict_core.inc(15): Including file '../../core\words/fetch.asm'
../../core\dict_core.inc(16): Including file '../../core\words/store.asm'
../../core\dict_core.inc(17): Including file '../../core\words/cstore.asm'
../../core\dict_core.inc(18): Including file '../../core\words/cfetch.asm'
../../core\dict_core.inc(19): Including file '../../core\words/fetch-u.asm'
../../core\dict_core.inc(20): Including file '../../core\words/store-u.asm'
../../core\dict_core.inc(23): Including file '../../core\words/dup.asm'
../../core\dict_core.inc(24): Including file '../../core\words/qdup.asm'
../../core\dict_core.inc(25): Including file '../../core\words/swap.asm'
../../core\dict_core.inc(26): Including file '../../core\words/over.asm'
../../core\dict_core.inc(27): Including file '../../core\words/drop.asm'
../../core\dict_core.inc(28): Including file '../../core\words/rot.asm'
../../core\dict_core.inc(31): Including file '../../core\words/r_from.asm'
../../core\dict_core.inc(32): Including file '../../core\words/to_r.asm'
../../core\dict_core.inc(33): Including file '../../core\words/r_fetch.asm'
../../core\dict_core.inc(36): Including file '../../core\words/notequal.asm'
../../core\dict_core.inc(37): Including file '../../core\words/equal.asm'
../../core\dict_core.inc(38): Including file '../../core\words/equalzero.asm'
../../core\dict_core.inc(39): Including file '../../core\words/less.asm'
../../core\dict_core.inc(40): Including file '../../core\words/greater.asm'
../../core\dict_core.inc(41): Including file '../../core\words/lesszero.asm'
../../core\dict_core.inc(42): Including file '../../core\words/zero.asm'
../../core\dict_core.inc(43): Including file '../../core\words/true.asm'
../../core\dict_core.inc(44): Including file '../../core\words/uless.asm'
../../core\dict_core.inc(45): Including file '../../core\words/ugreater.asm'
../../core\dict_core.inc(46): Including file '../../core\words/greaterzero.asm'
../../core\dict_core.inc(47): Including file '../../core\words/d-greater.asm'
../../core\dict_core.inc(48): Including file '../../core\words/d-less.asm'
../../core\dict_core.inc(49): Including file '../../core\words/log2.asm'
../../core\dict_core.inc(50): Including file '../../core\words/minus.asm'
../../core\dict_core.inc(51): Including file '../../core\words/plus.asm'
../../core\dict_core.inc(52): Including file '../../core\words/mstar.asm'
../../core\dict_core.inc(53): Including file '../../core\words/umslashmod.asm'
../../core\dict_core.inc(54): Including file '../../core\words/umstar.asm'
../../core\dict_core.inc(56): Including file '../../core\words/invert.asm'
../../core\dict_core.inc(57): Including file '../../core\words/2slash.asm'
../../core\dict_core.inc(58): Including file '../../core\words/2star.asm'
../../core\dict_core.inc(59): Including file '../../core\words/and.asm'
../../core\dict_core.inc(60): Including file '../../core\words/or.asm'
../../core\dict_core.inc(61): Including file '../../core\words/xor.asm'
../../core\dict_core.inc(63): Including file '../../core\words/1plus.asm'
../../core\dict_core.inc(64): Including file '../../core\words/1minus.asm'
../../core\dict_core.inc(65): Including file '../../core\words/lshift.asm'
../../core\dict_core.inc(66): Including file '../../core\words/rshift.asm'
../../core\dict_core.inc(67): Including file '../../core\words/plusstore.asm'
../../core\dict_core.inc(69): Including file '../../core\words/rpfetch.asm'
../../core\dict_core.inc(70): Including file '../../core\words/rpstore.asm'
../../core\dict_core.inc(71): Including file '../../core\words/spfetch.asm'
../../core\dict_core.inc(72): Including file '../../core\words/spstore.asm'
../../core\dict_core.inc(74): Including file '../../core\words/dodo.asm'
../../core\dict_core.inc(75): Including file '../../core\words/doqdo.asm'
../../core\dict_core.inc(76): Including file '../../core\words/i.asm'
../../core\dict_core.inc(77): Including file '../../core\words/doplusloop.asm'
../../core\dict_core.inc(78): Including file '../../core\words/doloop.asm'
../../core\dict_core.inc(79): Including file '../../core\words/unloop.asm'
../../core\dict_core.inc(83): Including file '../../core\words/cmove_g.asm'
../../core\dict_core.inc(84): Including file '../../core\words/byteswap.asm'
../../core\dict_core.inc(85): Including file '../../core\words/up.asm'
../../core\dict_core.inc(86): Including file '../../core\words/s_to_d.asm'
../../core\dict_core.inc(87): Including file '../../core\words/not.asm'
dict_appl_core.inc(2): Including file '../../core\words/store-e.asm'
dict_appl_core.inc(3): Including file '../../core\words/fetch-e.asm'
dict_appl_core.inc(5): Including file '../../core\words/store-i.asm'
dict_appl_core.inc(6): Including file '../../core\words/store-i_nrww.asm'
dict_appl_core.inc(7): Including file '../../core\words/fetch-i.asm'
../../core\amforth.asm(28): Including file '../../core\amforth-eeprom.inc'
                 
                 
                 ; Gloria Martorella <gloria.martorella@unipa.it>
                 ; DICGIM - University of Palermo - Italy
                 ; Viale delle Scienze - Ed. 6, 90128 Palermo, Italy
                 
                 ; Date: 2014
                 ; License: General Public License (GPL) Version2 from 1991.
                 
                 ; This is the template for an amforth project on Iris Mote
                 .include "macros.asm"
                 
                 ; some defaults
                 
                 .set WANT_ISR_TX = 0
                 .set WANT_ISR_RX = 1
                 .set WANT_IGNORECASE = 0
                 .set WANT_UNIFIED = 0
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_G_IN    = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                 delay_loop:
                           sbiw  Z, 1
                           brne  delay_loop
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; include the amforth device definition file. These
                 ; files include the *def.inc from atmel internally.
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  512
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 	elpm @0, Z+
                 	elpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_USART1 = 0
                 .set WANT_TWI = 0
                 .set WANT_SPI = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_PORTE = 0
                 .set WANT_PORTF = 0
                 .set WANT_PORTG = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_TIMER_COUNTER_5 = 0
                 .set WANT_TIMER_COUNTER_4 = 0
                 .set WANT_TIMER_COUNTER_3 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_EEPROM = 0
                 .set WANT_JTAG = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_CPU = 0
                 .equ intvecsize = 2 ; please verify; flash size: 131072 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d17f      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d17d      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d17b      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d179      	 rcall isr ; External Interrupt Request 3
                 .org 10
00000a d177      	 rcall isr ; External Interrupt Request 4
                 .org 12
00000c d175      	 rcall isr ; External Interrupt Request 5
                 .org 14
00000e d173      	 rcall isr ; External Interrupt Request 6
                 .org 16
000010 d171      	 rcall isr ; External Interrupt Request 7
                 .org 18
000012 d16f      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 20
000014 d16d      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 22
000016 d16b      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 24
000018 d169      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 26
00001a d167      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 28
00001c d165      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 30
00001e d163      	 rcall isr ; Timer/Counter2 Overflow
                 .org 32
000020 d161      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 34
000022 d15f      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 36
000024 d15d      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 38
000026 d15b      	 rcall isr ; Timer/Counter1 Compare Match C
                 .org 40
000028 d159      	 rcall isr ; Timer/Counter1 Overflow
                 .org 42
00002a d157      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 44
00002c d155      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 46
00002e d153      	 rcall isr ; Timer/Counter0 Overflow
                 .org 48
000030 d151      	 rcall isr ; SPI Serial Transfer Complete
                 .org 50
000032 d14f      	 rcall isr ; USART0, Rx Complete
                 .org 52
000034 d14d      	 rcall isr ; USART0 Data register Empty
                 .org 54
000036 d14b      	 rcall isr ; USART0, Tx Complete
                 .org 56
000038 d149      	 rcall isr ; Analog Comparator
                 .org 58
00003a d147      	 rcall isr ; ADC Conversion Complete
                 .org 60
00003c d145      	 rcall isr ; EEPROM Ready
                 .org 62
00003e d143      	 rcall isr ; Timer/Counter3 Capture Event
                 .org 64
000040 d141      	 rcall isr ; Timer/Counter3 Compare Match A
                 .org 66
000042 d13f      	 rcall isr ; Timer/Counter3 Compare Match B
                 .org 68
000044 d13d      	 rcall isr ; Timer/Counter3 Compare Match C
                 .org 70
000046 d13b      	 rcall isr ; Timer/Counter3 Overflow
                 .org 72
000048 d139      	 rcall isr ; USART1, Rx Complete
                 .org 74
00004a d137      	 rcall isr ; USART1 Data register Empty
                 .org 76
00004c d135      	 rcall isr ; USART1, Tx Complete
                 .org 78
00004e d133      	 rcall isr ; 2-wire Serial Interface
                 .org 80
000050 d131      	 rcall isr ; Store Program Memory Read
                 .org 82
000052 d12f      	 rcall isr ; Timer/Counter4 Capture Event
                 .org 84
000054 d12d      	 rcall isr ; Timer/Counter4 Compare Match A
                 .org 86
000056 d12b      	 rcall isr ; Timer/Counter4 Compare Match B
                 .org 88
000058 d129      	 rcall isr ; Timer/Counter4 Compare Match C
                 .org 90
00005a d127      	 rcall isr ; Timer/Counter4 Overflow
                 .org 92
00005c d125      	 rcall isr ; Timer/Counter5 Capture Event
                 .org 94
00005e d123      	 rcall isr ; Timer/Counter5 Compare Match A
                 .org 96
000060 d121      	 rcall isr ; Timer/Counter5 Compare Match B
                 .org 98
000062 d11f      	 rcall isr ; Timer/Counter5 Compare Match C
                 .org 100
000064 d11d      	 rcall isr ; Timer/Counter5 Overflow
                 .org 102
000066 d11b      	 rcall isr ; USART2, Rx Complete
                 .org 104
000068 d119      	 rcall isr ; USART2 Data register Empty
                 .org 106
00006a d117      	 rcall isr ; USART2, Tx Complete
                 .org 108
00006c d115      	 rcall isr ; USART3, Rx Complete
                 .org 110
00006e d113      	 rcall isr ; USART3 Data register Empty
                 .org 112
000070 d111      	 rcall isr ; USART3, Tx Complete
                 .equ INTVECTORS = 57
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000071 2000      	.dw 8192
                 mcu_eepromsize:
000072 1000      	.dw 4096
                 mcu_maxdp:
000073 ffff      	.dw 65535 
                 mcu_numints:
000074 0039      	.dw 57
                 mcu_name:
000075 000a      	.dw 10
000076 5441
000077 656d
000078 6167
000079 3231
00007a 3138      	.db "ATmega1281"
                 .set codestart=pc
                 
                 ; there are many WANT options available. There are two
                 ; places where they are defined: core/macros.asm and
                 ; core/devices/<mcutype>/device.asm. Setting the value
                 ; to 1 enables the feature, setting to 0 disables it.
                 ; Most options are disabled by default. You should never
                 ; change the files mentioned above, only change them in
                 ; this file.
                 
                 ; the dictionary search treats lowercase and uppercase
                 ; letters the same. Set to 0 if you do not want it
                 .set WANT_IGNORECASE = 1
                 
                 ; amforth needs two essential parameters
                 ; cpu clock in hertz, 1MHz is factory default
                 .equ F_CPU = 7372800
                 
                 ; terminal settings
                 ; check http://amforth.sourceforge.net/recipes/usart-settings.html
                 ; for further information
                 .set WANT_ISR_RX = 1 ; interrupt driven receive
                 .set WANT_ISR_TX = 0 ; send slowly but with less code space
                 
                 ; .set WANT_TIMER_COUNTER_3 = 1
                 ; 9600 @ 8N1 is commonly used.
                 .equ BAUD = 9600
                 
                 ; define which usart to use.
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .equ URXCaddr = URXC0addr
                   .equ UDREaddr = UDRE0addr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .equ USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .equ USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 .set pc_ = pc
                 .org URXCaddr
000032 940c 007b   jmp_ usart_rx_isr
                 .org pc_
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000200           usart_rx_in: .byte 1
000201           usart_rx_out: .byte 1
000202           usart_rx_data: .byte usart_rx_size+2
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
00007b 93af        push xl
00007c b7af        in xl, SREG
00007d 93af        push xl
00007e 93bf        push xh
00007f 93ef        push zl
000080 93ff        push zh
                 
000081 91b0 00c6   lds xh, USART_DATA
                   ; optional: check for certain character(s) (e.g. CTRL-C)
                   ; and trigger a soft interrupt instead of storing the
                   ; charater into the input queue.
000083 91a0 0200   lds xl,usart_rx_in
000085 e0e2        ldi zl, low(usart_rx_data)
000086 e0f2        ldi zh, high(usart_rx_data)
000087 0fea        add zl, xl
000088 1df3        adc zh, zeroh
000089 83b0        st Z, xh
                 
00008a 95a3        inc xl
00008b 70af        andi xl,usart_rx_mask
                 
00008c 93a0 0200   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
00008e 91ff        pop zh
00008f 91ef        pop zl
000090 91bf        pop xh
000091 91af        pop xl
000092 bfaf        out SREG, xl
000093 91af        pop xl
000094 9518        reti
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
000095 f000        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
000096 f14b        .dw XT_ZERO
000097 f040        .dw XT_DOLITERAL
000098 0200        .dw usart_rx_in
000099 f08a        .dw XT_STORE
                 
00009a f020        .dw XT_EXIT
                   .include "words/usart-rx-isr.asm"
                 
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
00009b ff06          .dw $ff06
00009c 7872
00009d 692d
00009e 7273          .db "rx-isr"
00009f 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
0000a0 f000          .dw DO_COLON
                 PFA_RX_ISR:
0000a1 00ba        .dw XT_RXQ_ISR
0000a2 f039        .dw XT_DOCONDBRANCH
0000a3 00a1        .dw PFA_RX_ISR
0000a4 f040        .dw XT_DOLITERAL
0000a5 0201        .dw usart_rx_out
0000a6 f0a1        .dw XT_CFETCH
0000a7 f0ba        .dw XT_DUP
0000a8 f244        .dw XT_1PLUS
0000a9 f040        .dw XT_DOLITERAL
0000aa 000f        .dw usart_rx_mask
0000ab f228        .dw XT_AND
0000ac f040        .dw XT_DOLITERAL
0000ad 0201        .dw usart_rx_out
0000ae f096        .dw XT_CSTORE
0000af f040        .dw XT_DOLITERAL
0000b0 0202        .dw usart_rx_data
0000b1 f1b2        .dw XT_PLUS
0000b2 f0a1        .dw XT_CFETCH
0000b3 f020        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
0000b4 ff07          .dw $ff07
0000b5 7872
0000b6 2d3f
0000b7 7369
0000b8 0072          .db "rx?-isr",0
0000b9 009b          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
0000ba f000          .dw DO_COLON
                 PFA_RXQ_ISR:
0000bb 072c        .dw XT_PAUSE
0000bc f040        .dw XT_DOLITERAL
0000bd 0201        .dw usart_rx_out
0000be f0a1        .dw XT_CFETCH
0000bf f040        .dw XT_DOLITERAL
0000c0 0200        .dw usart_rx_in
0000c1 f0a1        .dw XT_CFETCH
0000c2 f115        .dw XT_NOTEQUAL
0000c3 f020        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .if WANT_ISR_TX == 1
                 .else
                   .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
0000c4 ff07          .dw $ff07
0000c5 7874
0000c6 702d
0000c7 6c6f
0000c8 006c          .db "tx-poll",0
0000c9 00b4          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
0000ca f000          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
0000cb 00d8        .dw XT_TXQ_POLL
0000cc f039        .dw XT_DOCONDBRANCH
0000cd 00cb        .dw PFA_TX_POLL
                   ; send to usart
0000ce f040        .dw XT_DOLITERAL
0000cf 00c6        .dw USART_DATA
0000d0 f096        .dw XT_CSTORE
0000d1 f020        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
0000d2 ff08          .dw $ff08
0000d3 7874
0000d4 2d3f
0000d5 6f70
0000d6 6c6c          .db "tx?-poll"
0000d7 00c4          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000d8 f000          .dw DO_COLON
                 PFA_TXQ_POLL:
0000d9 072c        .dw XT_PAUSE
0000da f040        .dw XT_DOLITERAL
0000db 00c0        .dw USART_A
0000dc f0a1        .dw XT_CFETCH
0000dd f040        .dw XT_DOLITERAL
0000de 0020        .dw bm_USART_TXRD
0000df f228        .dw XT_AND
0000e0 f020        .dw XT_EXIT
                   .set XT_TX  = XT_TX_POLL
                   .set XT_TXQ = XT_TXQ_POLL
                   .set XT_USART_INIT_TX = XT_NOOP
                 .endif
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000e1 ff04        .dw $ff04
0000e2 6275
0000e3 7272        .db "ubrr"
0000e4 00d2        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000e5 f076        .dw PFA_DOVALUE
                 PFA_UBRR:          ; ( -- )
0000e6 000c        .dw EE_UBRRVAL
0000e7 f365        .dw XT_FETCHE
0000e8 f349        .dw XT_STOREE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000e9 ff06        .dw $ff06
0000ea 752b
0000eb 6173
0000ec 7472        .db "+usart"
0000ed 00e1        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000ee f000        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000ef f040        .dw XT_DOLITERAL
0000f0 0098        .dw USART_B_VALUE
0000f1 f040        .dw XT_DOLITERAL
0000f2 00c1        .dw USART_B
0000f3 f096        .dw XT_CSTORE
                 
0000f4 f040        .dw XT_DOLITERAL
0000f5 0006        .dw USART_C_VALUE
0000f6 f040        .dw XT_DOLITERAL
0000f7 00c2        .dw USART_C | bm_USARTC_en
0000f8 f096        .dw XT_CSTORE
                 
0000f9 00e5        .dw XT_UBRR
0000fa f0ba        .dw XT_DUP
0000fb f320        .dw XT_BYTESWAP
0000fc f040        .dw XT_DOLITERAL
0000fd 00c5        .dw BAUDRATE_HIGH
0000fe f096        .dw XT_CSTORE
0000ff f040        .dw XT_DOLITERAL
000100 00c4        .dw BAUDRATE_LOW
000101 f096        .dw XT_CSTORE
                 
000102 0095        .dw XT_USART_INIT_RX
000103 0820        .dw XT_USART_INIT_TX
000104 f020        .dw XT_EXIT
                 
                 .equ TIBSIZE  = $64    ; ANS94 needs at least 80 characters per line
                 .equ APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .equ NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 
                 ; settings for 1wire interface, if desired
                 .equ OW_PORT=PORTA
                 .EQU OW_BIT=4
                 
                 .include "words/IRIS1wire.asm"
                 
                 ; Gloria Martorella <gloria.martorella@unipa.it>
                 ; DICGIM - University of Palermo - Italy
                 ; Viale delle Scienze - Ed. 6, 90128 Palermo, Italy
                 
                 ; Date: 2014
                 ; License: General Public License (GPL) Version2 from 1991.
                 
                 ; Written on the basis of B. J. Rodriguez and Matthias Trute code 
                 ; "1wire.asm"
                 ; Written according to DS2401 datasheet 
                 
                 
                 ;.EQU OW_BIT=4
                 ;.equ OW_PORT=PORTE
                 .set OW_DDR=(OW_PORT-1)
                 .set OW_PIN=(OW_DDR-1)
                 
                 .macro PIN_INIT 
                     cbi OW_DDR, OW_BIT
                     cbi OW_PORT, OW_BIT
                 .endmacro
                 
                 
                 .macro OW_DRIVE 
                     sbi OW_DDR, OW_BIT
                     cbi OW_PORT, OW_BIT
                 .endmacro
                 
                 .macro OW_RELEASE
                     cbi OW_DDR, OW_BIT
                     sbi OW_PORT, OW_BIT 
                 .endmacro
                 
                 .macro RESET
                     savetos
                     clr tosh
                     OW_DRIVE     
                     DELAY   500
                     OW_RELEASE
                     DELAY   70 ; delayB
                     in tosl, OW_PIN
                     sbrs tosl, OW_BIT
                     ser  tosh
                    
                     DELAY   410
                     mov tosl, tosh
                 .endmacro
                 
                 
                 
                 VE_1W_INIT:
000105 ff07          .dw $ff07
000106 7731
000107 692e
000108 696e
000109 0074          .db "1w.init",0
00010a 00e9          .dw VE_HEAD
                     .set VE_HEAD = VE_1W_INIT
                 XT_1W_INIT:
00010b 010c          .dw PFA_1W_INIT
                 PFA_1W_INIT:
00010c 980c
00010d 9814          PIN_INIT
00010e 939a
00010f 938a
000110 2799
000111 9a0c
000112 9814
000113 e9e9
000114 e0f3
000115 9731
000116 f7f1
000117 c000
000118 980c
000119 9a14
00011a e8e1
00011b e0f0
00011c 9731
00011d f7f1
00011e b180
00011f ff84
000120 ef9f
000121 efe3
000122 e0f2
000123 9731
000124 f7f1
000125 c000
000126 2f89          RESET
000127 940c f004     jmp_ DO_NEXT
                     
                    
                     
                 
                 
                 
                 
                 
                 VE_1W_WRBYTE:
000129 ff09          .dw $ff09
00012a 7731
00012b 772e
00012c 6272
00012d 7479
words/IRIS1wire.asm(73): warning: .cseg .db misalignment - padding zero byte
00012e 0065          .db "1w.wrbyte"
00012f 0105          .dw VE_HEAD
                     .set VE_HEAD = VE_1W_WRBYTE
                 XT_1W_RESET:
000130 0131          .dw PFA_1W_WRBYTE
                 PFA_1W_WRBYTE:
000131 e383          ldi tosl, $33 
000132 e008          ldi temp0, 8
000133 9488          clc
                 PFA_1W_WRBYTE_LOOP:
000134 9587          ror tosl
000135 f490          brcc PFA_1W_WRBYTE1
000136 9a0c
000137 9814          OW_DRIVE 
000138 e0eb
000139 e0f0
00013a 9731
00013b f7f1          DELAY   6 ;tA
00013c 980c
00013d 9a14          OW_RELEASE
00013e e7e5
00013f e0f0
000140 9731
000141 f7f1
000142 c000
000143 0000          DELAY 64 ;tB
000144 950a          dec temp0
000145 f771          brne PFA_1W_WRBYTE_LOOP
000146 940c f004     jmp_ DO_NEXT
                 
                 PFA_1W_WRBYTE1:
000148 9a0c
000149 9814          OW_DRIVE 
00014a e6ee
00014b e0f0
00014c 9731
00014d f7f1
00014e c000          DELAY   60 ;tC
00014f 980c
000150 9a14          OW_RELEASE
000151 e1e2
000152 e0f0
000153 9731
000154 f7f1
000155 0000          DELAY 10 ;tD
000156 950a          dec temp0
000157 f6e1          brne PFA_1W_WRBYTE_LOOP
000158 940c f004     jmp_ DO_NEXT
                 
                 VE_1W_RDBYTE:
00015a ff09          .dw $ff09
00015b 7731
00015c 722e
00015d 6264
00015e 7479
words/IRIS1wire.asm(104): warning: .cseg .db misalignment - padding zero byte
00015f 0065          .db "1w.rdbyte"
000160 0129          .dw VE_HEAD
                     .set VE_HEAD = VE_1W_RDBYTE
                 XT_1W_RDBYTE:
000161 0162          .dw PFA_1W_RDBYTE
                 PFA_1W_RDBYTE:
000162 939a
000163 938a          savetos
000164 e080          ldi tosl, 0
000165 e090          ldi tosh, 0
000166 e008          ldi temp0, 8
                 PFA_1W_RDBYTE_LOOP:  
000167 9a0c
000168 9814          OW_DRIVE 
000169 e0eb
00016a e0f0
00016b 9731
00016c f7f1          DELAY 6   ; tA
00016d 980c
00016e 9a14          OW_RELEASE
00016f e1e0
000170 e0f0
000171 9731
000172 f7f1
000173 c000          DELAY 9   ; tE
000174 b120          in temp2, OW_PIN
000175 9488          clc
000176 fd24          sbrc temp2, OW_BIT
000177 9408          sec
000178 9587          ror tosl
000179 e6e5
00017a e0f0
00017b 9731
00017c f7f1
00017d 0000          DELAY   55 ; tF
00017e 950a          dec temp0
00017f f739          brne PFA_1W_RDBYTE_LOOP
                    
000180 940c f004     jmp_ DO_NEXT
                 
                 
                 
                 
                 
                 ; include the whole source tree.
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set pc_ = pc
                 .org $0000
000000 940c 0735   jmp_ PFA_COLD
                 .org pc_
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000214           intcur: .byte 1
000215           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
000182 920a          st -Y, r0
000183 b60f          in r0, SREG
000184 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
000185 900f          pop r0
000186 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
000187 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
000188 9200 0214     sts intcur, r0
00018a 9009          ld r0, Y+
00018b be0f          out SREG, r0
00018c 9009          ld r0, Y+
00018d 9468          set ; set the interrupt flag for the inner interpreter
00018e 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 .include "dict_minimum.inc"
                 
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 VE_F_CPU:
00018f ff05          .dw $ff05
000190 5f66
000191 7063
000192 0075          .db "f_cpu",0
000193 015a          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
000194 f000          .dw DO_COLON
                 PFA_F_CPU:
000195 f040          .dw XT_DOLITERAL
000196 8000          .dw (F_CPU % 65536)
000197 f040          .dw XT_DOLITERAL
000198 0070          .dw (F_CPU / 65536)
000199 f020          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
00019a ff05          .dw $ff05
00019b 7473
00019c 7461
00019d 0065          .db "state",0
00019e 018f          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
00019f f04e          .dw PFA_DOVARIABLE
                 PFA_STATE:
0001a0 0287          .dw ram_state
                 
                 .dseg
000287           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 VE_BASE:
0001a1 ff04          .dw $ff04
0001a2 6162
0001a3 6573          .db "base"
0001a4 019a          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
0001a5 f061          .dw PFA_DOUSER
                 PFA_BASE:
0001a6 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
0001a7 ff05          .dw $ff05
0001a8 6563
0001a9 6c6c
0001aa 0073          .db "cells",0
0001ab 01a1          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
0001ac f000          .dw DO_COLON
                 PFA_CELLS:
                 .if CELLSIZE == 2 ;
0001ad f220          .dw XT_2STAR
                 .else
                 .endif
0001ae f020          .dw XT_EXIT
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
0001af ff05          .dw $ff05
0001b0 6563
0001b1 6c6c
0001b2 002b          .db "cell+",0
0001b3 01a7          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
0001b4 f000          .dw DO_COLON
                 PFA_CELLPLUS:
                 .if CELLSIZE == 2 ;
0001b5 f244          .dw XT_1PLUS
0001b6 f244          .dw XT_1PLUS
                 .else
                 .endif
0001b7 f020          .dw XT_EXIT
                 ; maybe align data?
                 
                 .include "words/g_in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 VE_G_IN:
0001b8 ff03          .dw $ff03
0001b9 693e
0001ba 006e          .db ">in",0
0001bb 01af          .dw VE_HEAD
                     .set VE_HEAD = VE_G_IN
                 XT_G_IN:
0001bc f061          .dw PFA_DOUSER
                 PFA_G_IN:
0001bd 0018          .dw USER_G_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
0001be ff04          .dw $ff04
0001bf 7423
0001c0 6269          .db "#tib"
0001c1 01b8          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
0001c2 f04e          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
0001c3 0289          .dw ram_sharptib
                 
                 .dseg
000289           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
0001c4 ff03          .dw $ff03
0001c5 6170
0001c6 0064          .db "pad",0
0001c7 01be          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
0001c8 f000          .dw DO_COLON
                 PFA_PAD:
0001c9 0202          .dw XT_HERE
0001ca f040          .dw XT_DOLITERAL
0001cb 0064          .dw 100
0001cc f1b2          .dw XT_PLUS
0001cd f020          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
0001ce ff04          .dw $ff04
0001cf 6d65
0001d0 7469          .db "emit"
0001d1 01c4          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
0001d2 089d          .dw PFA_DODEFER
                 PFA_EMIT:
0001d3 000e          .dw USER_EMIT
0001d4 0875          .dw XT_UDEFERFETCH
0001d5 087c          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
0001d6 ff05          .dw $ff05
0001d7 6d65
0001d8 7469
0001d9 003f          .db "emit?",0
0001da 01ce          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
0001db 089d          .dw PFA_DODEFER
                 PFA_EMITQ:
0001dc 0010          .dw USER_EMITQ
0001dd 0875          .dw XT_UDEFERFETCH
0001de 087c          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
0001df ff03          .dw $ff03
0001e0 656b
0001e1 0079          .db "key",0
0001e2 01d6          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
0001e3 089d          .dw PFA_DODEFER
                 PFA_KEY:
0001e4 0012          .dw USER_KEY
0001e5 0875          .dw XT_UDEFERFETCH
0001e6 087c          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
0001e7 ff04          .dw $ff04
0001e8 656b
0001e9 3f79          .db "key?"
0001ea 01df          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
0001eb 089d          .dw PFA_DODEFER
                 PFA_KEYQ:
0001ec 0014          .dw USER_KEYQ
0001ed 0875          .dw XT_UDEFERFETCH
0001ee 087c          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
0001ef ff02          .dw $ff02
0001f0 7064          .db "dp"
0001f1 01e7          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
0001f2 f076          .dw PFA_DOVALUE
                 PFA_DP:
0001f3 0002          .dw EE_DP
0001f4 f365          .dw XT_FETCHE
0001f5 f349          .dw XT_STOREE
                 .include "words/edp.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EDP:
0001f6 ff03          .dw $ff03
0001f7 6465
0001f8 0070          .db "edp",0
0001f9 01ef          .dw VE_HEAD
                     .set VE_HEAD = VE_EDP
                 XT_EDP:
0001fa f076          .dw PFA_DOVALUE
                 PFA_EDP:
0001fb 0006          .dw EE_EDP
0001fc f365          .dw XT_FETCHE
0001fd f349          .dw XT_STOREE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
0001fe ff04          .dw $ff04
0001ff 6568
000200 6572          .db "here"
000201 01f6          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
000202 f076          .dw PFA_DOVALUE
                 PFA_HERE:
000203 0004          .dw EE_HERE
000204 f365          .dw XT_FETCHE
000205 f349          .dw XT_STOREE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
000206 ff05          .dw $ff05
000207 6c61
000208 6f6c
000209 0074          .db "allot",0
00020a 01fe          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
00020b f000          .dw DO_COLON
                 PFA_ALLOT:
00020c 0202          .dw XT_HERE
00020d f1b2          .dw XT_PLUS
00020e 0853          .dw XT_DOTO
00020f 0203          .dw PFA_HERE
000210 f020          .dw XT_EXIT
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
000211 ff08          .dw $ff08
000212 6328
000213 6572
000214 7461
000215 2965          .db "(create)"
000216 0206          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
000217 f000          .dw DO_COLON
                 PFA_DOCREATE:
000218 06a2          .dw XT_PARSENAME
000219 022b          .dw XT_WLSCOPE
00021a f0ba          .dw XT_DUP
00021b f101          .dw XT_TO_R
00021c 0e1d          .dw XT_HEADER
00021d f0f8          .dw XT_R_FROM
                 .dseg
00028b           COLON_SMUDGE: .byte 4
                 .cseg
00021e f040          .dw XT_DOLITERAL
00021f 028d          .dw COLON_SMUDGE+2
000220 f08a          .dw XT_STORE		; save wid
000221 f040          .dw XT_DOLITERAL
000222 028b          .dw COLON_SMUDGE+0
000223 f08a          .dw XT_STORE		; save NFA
                 
000224 f020          .dw XT_EXIT
                 
                 ; ( addr len -- wid )
                 ; Compiler
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 VE_WLSCOPE:
000225 ff07          .dw $ff07
000226 6c77
000227 6373
000228 706f
000229 0065          .db "wlscope",0
00022a 0211          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
00022b 089d          .dw PFA_DODEFER
                 PFA_WLSCOPE:
00022c 0052          .dw EE_WLSCOPE
00022d 0861          .dw XT_EDEFERFETCH
00022e 0866          .dw XT_EDEFERSTORE
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 VE_BACKSLASH:
00022f 0001          .dw $0001
000230 005c          .db "\",0
000231 0225          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
000232 f000          .dw DO_COLON
                 PFA_BACKSLASH:
000233 0687          .dw XT_SOURCE
000234 f0cd          .dw XT_SWAP
000235 f0e2          .dw XT_DROP
000236 01bc          .dw XT_G_IN
000237 f08a          .dw XT_STORE
000238 f020          .dw XT_EXIT
                 .include "words/lparenthesis.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 VE_LPARENTHESIS:
000239 0001          .dw $0001
00023a 0028          .db "(" ,0
00023b 022f          .dw VE_HEAD
                     .set VE_HEAD = VE_LPARENTHESIS
                 XT_LPARENTHESIS:
00023c f000          .dw DO_COLON
                 PFA_LPARENTHESIS:
00023d f040          .dw XT_DOLITERAL
00023e 0029          .dw $29
00023f 0653          .dw XT_PARSE
000240 f0e2          .dw XT_DROP
000241 f0e2          .dw XT_DROP
000242 f020          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 VE_COMPILE:
000243 ff07          .dw $ff07
000244 6f63
000245 706d
000246 6c69
000247 0065          .db "compile",0
000248 0239          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
000249 f000          .dw DO_COLON
                 PFA_COMPILE:
00024a f0f8          .dw XT_R_FROM
00024b f0ba          .dw XT_DUP
00024c f244          .dw XT_1PLUS
00024d f101          .dw XT_TO_R
00024e f3d7          .dw XT_FETCHI
00024f 0254          .dw XT_COMMA
000250 f020          .dw XT_EXIT
                 
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
000251 ff01          .dw $ff01
000252 002c          .db ',',0 ; ,
000253 0243          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
000254 f000          .dw DO_COLON
                 PFA_COMMA:
000255 01f2          .dw XT_DP
000256 f379          .dw XT_STOREI
000257 01f2          .dw XT_DP
000258 f244          .dw XT_1PLUS
000259 0853          .dw XT_DOTO
00025a 01f3          .dw PFA_DP
00025b f020          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 VE_BRACKETTICK:
00025c 0003          .dw $0003
00025d 275b
00025e 005d          .db "[']",0
00025f 0251          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
000260 f000          .dw DO_COLON
                 PFA_BRACKETTICK:
000261 0249          .dw XT_COMPILE
000262 f040          .dw XT_DOLITERAL
000263 04e2          .dw XT_TICK
000264 0254          .dw XT_COMMA
000265 f020          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 2
                 VE_BIN:
000266 ff03          .dw $ff03
000267 6962
000268 006e          .db "bin",0
000269 025c          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
00026a f000          .dw DO_COLON
                 PFA_BIN:
00026b f040          .dw XT_DOLITERAL
00026c 0002          .dw 2
00026d 01a5          .dw XT_BASE
00026e f08a          .dw XT_STORE
00026f f020          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 VE_DECIMAL:
000270 ff07          .dw $ff07
000271 6564
000272 6963
000273 616d
000274 006c          .db "decimal",0
000275 0266          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
000276 f000          .dw DO_COLON
                 PFA_DECIMAL:
000277 f040          .dw XT_DOLITERAL
000278 000a          .dw 10
000279 01a5          .dw XT_BASE
00027a f08a          .dw XT_STORE
00027b f020          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for number conversion to 16
                 VE_HEX:
00027c ff03          .dw $ff03
00027d 6568
00027e 0078          .db "hex",0
00027f 0270          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
000280 f000          .dw DO_COLON
                 PFA_HEX:
000281 f040          .dw XT_DOLITERAL
000282 0010          .dw 16
000283 01a5          .dw XT_BASE
000284 f08a          .dw XT_STORE
000285 f020          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 VE_BL:
000286 ff02          .dw $ff02
000287 6c62          .db "bl"
000288 027c          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
000289 f04e          .dw PFA_DOVARIABLE
                 PFA_BL:
00028a 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
00028b ff07          .dw $ff07
00028c 7574
00028d 6e72
00028e 656b
00028f 0079          .db "turnkey",0
000290 0286          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
000291 089d          .dw PFA_DODEFER
                 PFA_TURNKEY:
000292 0008          .dw EE_TURNKEY
000293 0861          .dw XT_EDEFERFETCH
000294 0866          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/starslashmod.asm"
                 
                 ; Arithmetics
                 ; signed multiply n1 * n2 and division  with n3 with double precision intermediate and remainder
                 VE_STARSLASHMOD:
000295 ff05          .dw $ff05
000296 2f2a
000297 6f6d
000298 0064          .db "*/mod",0
000299 028b          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASHMOD
                 XT_STARSLASHMOD:
00029a f000          .dw DO_COLON
                 PFA_STARSLASHMOD:
00029b f101          .dw XT_TO_R
00029c f1bb          .dw XT_MSTAR
00029d f0f8          .dw XT_R_FROM
00029e f1d7          .dw XT_UMSLASHMOD
00029f f020          .dw XT_EXIT
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
0002a0 ff04          .dw $ff04
0002a1 6d2f
0002a2 646f          .db "/mod"
0002a3 0295          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
0002a4 02a5          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
0002a5 019c          movw temp2, tosl
                     
0002a6 9109          ld temp0, Y+
0002a7 9119          ld temp1, Y+
                 
0002a8 2f41          mov	temp6,temp1	;move dividend High to sign register
0002a9 2743          eor	temp6,temp3	;xor divisor High with sign register
0002aa ff17          sbrs	temp1,7	;if MSB in dividend set
0002ab c004          rjmp	PFA_SLASHMOD_1
0002ac 9510          com	temp1		;    change sign of dividend
0002ad 9500          com	temp0		
0002ae 5f0f          subi	temp0,low(-1)
0002af 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
0002b0 ff37          sbrs	temp3,7	;if MSB in divisor set
0002b1 c004          rjmp	PFA_SLASHMOD_2
0002b2 9530          com	temp3		;    change sign of divisor
0002b3 9520          com	temp2		
0002b4 5f2f          subi	temp2,low(-1)
0002b5 4f3f          sbci	temp3,high(-1)
0002b6 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
0002b7 18ff          sub	temp5,temp5;clear remainder High byte and carry
0002b8 e151          ldi	temp7,17	;init loop counter
                 
0002b9 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
0002ba 1f11          rol	temp1
0002bb 955a          dec	temp7		;decrement counter
0002bc f439          brne	PFA_SLASHMOD_5		;if done
0002bd ff47          sbrs	temp6,7		;    if MSB in sign register set
0002be c004          rjmp	PFA_SLASHMOD_4
0002bf 9510          com	temp1	;        change sign of result
0002c0 9500          com	temp0
0002c1 5f0f          subi	temp0,low(-1)
0002c2 4f1f          sbci	temp1,high(-1)
0002c3 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
0002c4 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
0002c5 1cff          rol	temp5
0002c6 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
0002c7 0af3          sbc	temp5,temp3	;
0002c8 f420          brcc	PFA_SLASHMOD_6		;if result negative
0002c9 0ee2          add	temp4,temp2	;    restore remainder
0002ca 1ef3          adc	temp5,temp3
0002cb 9488          clc			;    clear carry to be shifted into result
0002cc cfec          rjmp	PFA_SLASHMOD_3		;else
0002cd 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
0002ce cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
0002cf 92fa          st -Y,temp5
0002d0 92ea          st -Y,temp4
                 
                     ; put quotient on stack
0002d1 01c8          movw tosl, temp0
0002d2 940c f004     jmp_ DO_NEXT
                 .include "words/starslash.asm"
                 
                 ; Arithmetics
                 ; signed multiply and division with double precision intermediate
                 VE_STARSLASH:
0002d4 ff02          .dw $ff02
0002d5 2f2a          .db "*/"
0002d6 02a0          .dw VE_HEAD
                     .set VE_HEAD = VE_STARSLASH
                 XT_STARSLASH:
0002d7 f000          .dw DO_COLON
                 PFA_STARSLASH:
0002d8 029a          .dw XT_STARSLASHMOD
0002d9 f0cd          .dw XT_SWAP
0002da f0e2          .dw XT_DROP
0002db f020          .dw XT_EXIT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
0002dc ff05          .dw $ff05
0002dd 2f75
0002de 6f6d
0002df 0064          .db "u/mod",0
0002e0 02d4          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
0002e1 f000          .dw DO_COLON
                 PFA_USLASHMOD:
0002e2 f101          .dw XT_TO_R
0002e3 f14b          .dw XT_ZERO
0002e4 f0f8          .dw XT_R_FROM
0002e5 f1d7          .dw XT_UMSLASHMOD
0002e6 f020          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
0002e7 ff06          .dw $ff06
0002e8 656e
0002e9 6167
0002ea 6574          .db "negate"
0002eb 02dc          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
0002ec f000          .dw DO_COLON
                 PFA_NEGATE:
0002ed f212          .dw XT_INVERT
0002ee f244          .dw XT_1PLUS
0002ef f020          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 VE_SLASH:
0002f0 ff01          .dw $ff01
0002f1 002f          .db "/",0
0002f2 02e7          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
0002f3 f000          .dw DO_COLON
                 PFA_SLASH:
0002f4 02a4          .dw XT_SLASHMOD
0002f5 f0cd          .dw XT_SWAP
0002f6 f0e2          .dw XT_DROP
0002f7 f020          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 VE_MOD:
0002f8 ff03          .dw $ff03
0002f9 6f6d
0002fa 0064          .db "mod",0
0002fb 02f0          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
0002fc f000          .dw DO_COLON
                 PFA_MOD:
0002fd 02a4          .dw XT_SLASHMOD
0002fe f0e2          .dw XT_DROP
0002ff f020          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
000300 ff03          .dw $ff03
000301 6261
000302 0073          .db "abs",0
000303 02f8          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
000304 f000          .dw DO_COLON
                 PFA_ABS:
000305 f0ba          .dw XT_DUP
000306 f144          .dw XT_LESSZERO
000307 f039          .dw XT_DOCONDBRANCH
000308 030a          .dw PFA_ABS1
000309 02ec          .dw XT_NEGATE
                 PFA_ABS1:
00030a f020          .dw XT_EXIT
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 VE_MIN:
00030b ff03          .dw $ff03
00030c 696d
00030d 006e          .db "min",0
00030e 0300          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
00030f f000          .dw DO_COLON
                 PFA_MIN:
000310 f0d8          .dw XT_OVER
000311 f0d8          .dw XT_OVER
000312 f139          .dw XT_GREATER
000313 f039          .dw XT_DOCONDBRANCH
000314 0316          .dw PFA_MIN1
000315 f0cd          .dw XT_SWAP
                 PFA_MIN1:
000316 f0e2          .dw XT_DROP
000317 f020          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 VE_MAX:
000318 ff03          .dw $ff03
000319 616d
00031a 0078          .db "max",0
00031b 030b          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
00031c f000          .dw DO_COLON
                 PFA_MAX:
00031d f0d8          .dw XT_OVER
00031e f0d8          .dw XT_OVER
00031f f12f          .dw XT_LESS
000320 f039          .dw XT_DOCONDBRANCH
000321 0323          .dw PFA_MAX1
000322 f0cd          .dw XT_SWAP
                 PFA_MAX1:
000323 f0e2          .dw XT_DROP
000324 f020          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 VE_WITHIN:
000325 ff06          .dw $ff06
000326 6977
000327 6874
000328 6e69          .db "within"
000329 0318          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
00032a f000          .dw DO_COLON
                 PFA_WITHIN:
00032b f0d8          .dw XT_OVER
00032c f1a8          .dw XT_MINUS
00032d f101          .dw XT_TO_R
00032e f1a8          .dw XT_MINUS
00032f f0f8          .dw XT_R_FROM
000330 f15d          .dw XT_ULESS
000331 f020          .dw XT_EXIT
                 ; : within >r over > swap r> > or 0= ;
                 ; alternativly
                 ; : within over - >r - r> u< ;
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 VE_TOUPPER:
000332 ff07          .dw $ff07 
000333 6f74
000334 7075
000335 6570
000336 0072          .db "toupper",0
000337 0325          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
000338 f000          .dw DO_COLON 
                 PFA_TOUPPER:
000339 f0ba          .dw XT_DUP 
00033a f040          .dw XT_DOLITERAL 
00033b 0061          .dw 'a' 
00033c f040          .dw XT_DOLITERAL 
00033d 007b          .dw 'z'+1
00033e 032a          .dw XT_WITHIN 
00033f f039          .dw XT_DOCONDBRANCH
000340 0344          .dw PFA_TOUPPER0 
000341 f040          .dw XT_DOLITERAL
000342 00df          .dw $df ; inverse of 0x20
000343 f228          .dw XT_AND 
                 PFA_TOUPPER0:
000344 f020          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 VE_TOLOWER:
000345 ff07          .dw $ff07
000346 6f74
000347 6f6c
000348 6577
000349 0072          .db "tolower",0
00034a 0332          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
00034b f000          .dw DO_COLON
                 PFA_TOLOWER:
00034c f0ba          .dw XT_DUP
00034d f040          .dw XT_DOLITERAL
00034e 0041          .dw 'A'
00034f f040          .dw XT_DOLITERAL
000350 005b          .dw 'Z'+1
000351 032a          .dw XT_WITHIN
000352 f039          .dw XT_DOCONDBRANCH
000353 0357          .dw PFA_TOLOWER0 
000354 f040          .dw XT_DOLITERAL
000355 0020          .dw $20 
000356 f231          .dw XT_OR 
                 PFA_TOLOWER0:
000357 f020          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
000358 ff03          .dw $ff03
000359 6c68
00035a 0064          .db "hld",0
00035b 0345          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
00035c f04e          .dw PFA_DOVARIABLE
                 PFA_HLD:
00035d 028f          .dw ram_hld
                 
                 .dseg
00028f           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 VE_HOLD:
00035e ff04          .dw $ff04
00035f 6f68
000360 646c          .db "hold"
000361 0358          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
000362 f000          .dw DO_COLON
                 PFA_HOLD:
000363 035c          .dw XT_HLD
000364 f0ba          .dw XT_DUP
000365 f082          .dw XT_FETCH
000366 f24a          .dw XT_1MINUS
000367 f0ba          .dw XT_DUP
000368 f101          .dw XT_TO_R
000369 f0cd          .dw XT_SWAP
00036a f08a          .dw XT_STORE
00036b f0f8          .dw XT_R_FROM
00036c f096          .dw XT_CSTORE
00036d f020          .dw XT_EXIT
                 .include "words/l_sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 VE_L_SHARP:
00036e ff02          .dw $ff02
00036f 233c          .db "<#"
000370 035e          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
000371 f000          .dw DO_COLON
                 PFA_L_SHARP:
000372 01c8          .dw XT_PAD
000373 035c          .dw XT_HLD
000374 f08a          .dw XT_STORE
000375 f020          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 VE_SHARP:
000376 ff01          .dw $ff01
000377 0023          .db "#",0
000378 036e          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
000379 f000          .dw DO_COLON
                 PFA_SHARP:
00037a 01a5          .dw XT_BASE
00037b f082          .dw XT_FETCH
00037c 03fa          .dw XT_UDSLASHMOD
00037d f0ea          .dw XT_ROT
00037e f040          .dw XT_DOLITERAL
00037f 0009          .dw 9
000380 f0d8          .dw XT_OVER
000381 f12f          .dw XT_LESS
000382 f039          .dw XT_DOCONDBRANCH
000383 0387          .dw PFA_SHARP1
000384 f040          .dw XT_DOLITERAL
000385 0007          .dw 7
000386 f1b2          .dw XT_PLUS
                 PFA_SHARP1:
000387 f040          .dw XT_DOLITERAL
000388 0030          .dw $30
000389 f1b2          .dw XT_PLUS
00038a 0362          .dw XT_HOLD
00038b f020          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp_s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 VE_SHARP_S:
00038c ff02          .dw $ff02
00038d 7323          .db "#s"
00038e 0376          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
00038f f000          .dw DO_COLON
                 PFA_SHARP_S:
000390 0379          .dw XT_SHARP
000391 f0d8          .dw XT_OVER
000392 f0d8          .dw XT_OVER
000393 f231          .dw XT_OR
000394 f129          .dw XT_EQUALZERO
000395 f039          .dw XT_DOCONDBRANCH
000396 0390          .dw PFA_SHARP_S
000397 f020          .dw XT_EXIT
                 .include "words/sharp_g.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 VE_SHARP_G:
000398 ff02          .dw $ff02
000399 3e23          .db "#>"
00039a 038c          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
00039b f000          .dw DO_COLON
                 PFA_SHARP_G:
00039c f0e2          .dw XT_DROP
00039d f0e2          .dw XT_DROP
00039e 035c          .dw XT_HLD
00039f f082          .dw XT_FETCH
0003a0 f0ba          .dw XT_DUP
0003a1 01c8          .dw XT_PAD
0003a2 f0cd          .dw XT_SWAP
0003a3 f1a8          .dw XT_MINUS
0003a4 f020          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 VE_SIGN:
0003a5 ff04          .dw $ff04
0003a6 6973
0003a7 6e67          .db "sign"
0003a8 0398          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
0003a9 f000          .dw DO_COLON
                 PFA_SIGN:
0003aa f144          .dw XT_LESSZERO
0003ab f039          .dw XT_DOCONDBRANCH
0003ac 03b0          .dw PFA_SIGN1
0003ad f040          .dw XT_DOLITERAL
0003ae 002d          .dw $2d
0003af 0362          .dw XT_HOLD
                 PFA_SIGN1:
0003b0 f020          .dw XT_EXIT
                 .include "words/ddotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 VE_DDOTR:
0003b1 ff03          .dw $ff03
0003b2 2e64
0003b3 0072          .db "d.r",0
0003b4 03a5          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
0003b5 f000          .dw DO_COLON
                 PFA_DDOTR:
0003b6 f101          .dw XT_TO_R
0003b7 f0cd          .dw XT_SWAP
0003b8 f0d8          .dw XT_OVER
0003b9 0942          .dw XT_DABS
0003ba 0371          .dw XT_L_SHARP
0003bb 038f          .dw XT_SHARP_S
0003bc f0ea          .dw XT_ROT
0003bd 03a9          .dw XT_SIGN
0003be 039b          .dw XT_SHARP_G
0003bf f0f8          .dw XT_R_FROM
0003c0 f0d8          .dw XT_OVER
0003c1 f1a8          .dw XT_MINUS
0003c2 04c4          .dw XT_SPACES
0003c3 04d3          .dw XT_TYPE
0003c4 f020          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dotr.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 VE_DOTR:
0003c5 ff02          .dw $ff02
0003c6 722e          .db ".r"
0003c7 03b1          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
0003c8 f000          .dw DO_COLON
                 PFA_DOTR:
0003c9 f101          .dw XT_TO_R
0003ca f33b          .dw XT_S2D
0003cb f0f8          .dw XT_R_FROM
0003cc 03b5          .dw XT_DDOTR
0003cd f020          .dw XT_EXIT
                 .include "words/ddot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 VE_DDOT:
0003ce ff02          .dw $ff02
0003cf 2e64          .db "d."
0003d0 03c5          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
0003d1 f000          .dw DO_COLON
                 PFA_DDOT:
0003d2 f14b          .dw XT_ZERO
0003d3 03b5          .dw XT_DDOTR
0003d4 04bb          .dw XT_SPACE
0003d5 f020          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 VE_DOT:
0003d6 ff01          .dw $ff01
0003d7 002e          .db ".",0
0003d8 03ce          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
0003d9 f000          .dw DO_COLON
                 PFA_DOT:
0003da f33b          .dw XT_S2D
0003db 03d1          .dw XT_DDOT
0003dc f020          .dw XT_EXIT
                 .include "words/uddot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 VE_UDDOT:
0003dd ff03          .dw $ff03
0003de 6475
0003df 002e          .db "ud.",0
0003e0 03d6          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
0003e1 f000          .dw DO_COLON
                 PFA_UDDOT:
0003e2 f14b          .dw XT_ZERO
0003e3 03ea          .dw XT_UDDOTR
0003e4 04bb          .dw XT_SPACE
0003e5 f020          .dw XT_EXIT
                 .include "words/uddotr.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 VE_UDDOTR:
0003e6 ff04          .dw $ff04
0003e7 6475
0003e8 722e          .db "ud.r"
0003e9 03dd          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
0003ea f000          .dw DO_COLON
                 PFA_UDDOTR:
0003eb f101          .dw XT_TO_R
0003ec 0371          .dw XT_L_SHARP
0003ed 038f          .dw XT_SHARP_S
0003ee 039b          .dw XT_SHARP_G
0003ef f0f8          .dw XT_R_FROM
0003f0 f0d8          .dw XT_OVER
0003f1 f1a8          .dw XT_MINUS
0003f2 04c4          .dw XT_SPACES
0003f3 04d3          .dw XT_TYPE
0003f4 f020          .dw XT_EXIT
                 .include "words/udslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 VE_UDSLASHMOD:
0003f5 ff06          .dw $ff06
0003f6 6475
0003f7 6d2f
0003f8 646f          .db "ud/mod"
0003f9 03e6          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
0003fa f000          .dw DO_COLON
                 PFA_UDSLASHMOD:
0003fb f101          .dw XT_TO_R
0003fc f14b          .dw XT_ZERO
0003fd f10a          .dw XT_R_FETCH
0003fe f1d7          .dw XT_UMSLASHMOD
0003ff f0f8          .dw XT_R_FROM
000400 f0cd          .dw XT_SWAP
000401 f101          .dw XT_TO_R
000402 f1d7          .dw XT_UMSLASHMOD
000403 f0f8          .dw XT_R_FROM
000404 f020          .dw XT_EXIT
                 ; : ud/mod    ( ud1 n -- rem ud2 ) >r 0 r@ um/mod r> swap >r um/mod r> ; 
                 .include "words/digitq.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 VE_DIGITQ:
000405 ff06          .dw $ff06 
000406 6964
000407 6967
000408 3f74          .db "digit?"
000409 03f5          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
00040a f000          .dw DO_COLON 
                 PFA_DIGITQ:
00040b 0338          .dw XT_TOUPPER
00040c f040          .dw XT_DOLITERAL 
00040d 0030          .dw $30 
00040e f1a8          .dw XT_MINUS 
00040f f0ba          .dw XT_DUP 
000410 f040          .dw XT_DOLITERAL
000411 0009          .dw $09 
000412 f168          .dw XT_UGREATER 
000413 f039          .dw XT_DOCONDBRANCH
000414 0421          .dw PFA_DIGITQ0 
000415 f040          .dw XT_DOLITERAL
000416 0007          .dw $07 
000417 f1a8          .dw XT_MINUS 
000418 f0ba          .dw XT_DUP 
000419 f040          .dw XT_DOLITERAL
00041a 0009          .dw $09 
00041b 0430          .dw XT_ULESSEQUAL
00041c f039          .dw XT_DOCONDBRANCH
00041d 0421          .dw PFA_DIGITQ1 
00041e f0e2          .dw XT_DROP 
00041f f14b          .dw XT_ZERO
000420 f020          .dw XT_EXIT 
                 PFA_DIGITQ1:
                 PFA_DIGITQ0:
000421 f0ba          .dw XT_DUP 
000422 01a5          .dw XT_BASE 
000423 f082          .dw XT_FETCH 
000424 0438          .dw XT_UGREATEREQUAL
000425 f039          .dw XT_DOCONDBRANCH
000426 042a          .dw PFA_DIGITQ2 
000427 f0e2          .dw XT_DROP 
000428 f14b          .dw XT_ZERO
000429 f020          .dw XT_EXIT 
                 PFA_DIGITQ2:
00042a f154          .dw XT_TRUE
00042b f020          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is less then or equal to u2
                 VE_ULESSEQUAL:
00042c ff03          .dw $ff03 
00042d 3c75
00042e 003d          .db "u<=",0
00042f 0405          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESSEQUAL
                 XT_ULESSEQUAL:
000430 f000          .dw DO_COLON 
                 PFA_ULESSEQUAL:
000431 f168          .dw XT_UGREATER 
000432 f212          .dw XT_INVERT 
000433 f020          .dw XT_EXIT 
                 
                 ; ( u1 u2 -- flag ) 
                 ; Compare
                 ; compare two unsigned numbers, returns true flag if u1 is greater then or equal to u2
                 VE_UGREATEREQUAL:
000434 ff03          .dw $ff03 
000435 3e75
000436 003d          .db "u>=",0
000437 042c          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATEREQUAL
                 XT_UGREATEREQUAL:
000438 f000          .dw DO_COLON 
                 PFA_UGREATEREQUAL:
000439 f15d          .dw XT_ULESS 
00043a f212          .dw XT_INVERT 
00043b f020          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 VE_DOSLITERAL:
00043c ff0a        .dw $ff0a
00043d 7328
00043e 696c
00043f 6574
000440 6172
000441 296c        .db "(sliteral)"
000442 0434        .dw VE_HEAD
                   .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
000443 f000        .dw DO_COLON
                 PFA_DOSLITERAL:
000444 f0f8        .dw XT_R_FROM   ; ( -- addr )
000445 f0ba        .dw XT_DUP      ; ( -- addr addr )
000446 f0ba        .dw XT_DUP
000447 f3d7        .dw XT_FETCHI   ; ( -- addr addr n )
000448 f0cd        .dw XT_SWAP
000449 f244        .dw XT_1PLUS
00044a f0cd        .dw XT_SWAP
00044b f0ea        .dw XT_ROT      ; ( -- addr' n addr )
00044c f0d8        .dw XT_OVER     ; ( -- addr' n addr n)
00044d f244        .dw XT_1PLUS
00044e f219        .dw XT_2SLASH   ; ( -- addr' n addr k )
00044f f1b2        .dw XT_PLUS     ; ( -- addr' n addr'' )
000450 f244        .dw XT_1PLUS
000451 f101        .dw XT_TO_R     ; ( -- )
000452 f020        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
000453 ff02        .dw $ff02
000454 2c73        .db "s",$2c
000455 043c        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
000456 f000          .dw DO_COLON
                 PFA_SCOMMA:
000457 f0ba          .dw XT_DUP
000458 045a          .dw XT_DOSCOMMA
000459 f020          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
00045a f000          .dw DO_COLON
                 PFA_DOSCOMMA:
00045b 0254          .dw XT_COMMA
00045c f0ba          .dw XT_DUP   ; ( --addr len len)
00045d f219          .dw XT_2SLASH ; ( -- addr len len/2
00045e f0cd          .dw XT_SWAP   ; ( -- addr len/2 len
00045f f0d8          .dw XT_OVER   ; ( -- addr len/2 len len/2
000460 f220          .dw XT_2STAR  ; ( -- addr len/2 len len'
000461 f1a8          .dw XT_MINUS  ; ( -- addr len/2 rem
000462 f101          .dw XT_TO_R
000463 f14b          .dw XT_ZERO
000464 f2b9          .dw XT_DOQDO
000465 046c          .dw PFA_SCOMMA2
                 PFA_SCOMMA1:
000466 f0ba          .dw XT_DUP         ; ( -- addr addr )
000467 f082          .dw XT_FETCH       ; ( -- addr c1c2 )
000468 0254          .dw XT_COMMA       ; ( -- addr )
000469 01b4          .dw XT_CELLPLUS    ; ( -- addr+cell )
00046a f2ea          .dw XT_DOLOOP
00046b 0466          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
00046c f0f8          .dw XT_R_FROM
00046d f173          .dw XT_GREATERZERO
00046e f039          .dw XT_DOCONDBRANCH
00046f 0473          .dw PFA_SCOMMA3
000470 f0ba            .dw XT_DUP     ; well, tricky
000471 f0a1            .dw XT_CFETCH
000472 0254            .dw XT_COMMA
                 PFA_SCOMMA3:
000473 f0e2          .dw XT_DROP        ; ( -- )
000474 f020          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
000475 ff05          .dw $ff05
000476 7469
000477 7079
000478 0065          .db "itype",0
000479 0453          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
00047a f000          .dw DO_COLON
                 PFA_ITYPE:
00047b f0ba          .dw XT_DUP    ; ( --addr len len)
00047c f219          .dw XT_2SLASH ; ( -- addr len len/2
00047d f0cd          .dw XT_SWAP   ; ( -- addr len/2 len
00047e f0d8          .dw XT_OVER   ; ( -- addr len/2 len len/2
00047f f220          .dw XT_2STAR  ; ( -- addr len/2 len len'
000480 f1a8          .dw XT_MINUS  ; ( -- addr len/2 rem
000481 f101          .dw XT_TO_R
000482 f14b          .dw XT_ZERO
000483 f2b9          .dw XT_DOQDO
000484 048d          .dw PFA_ITYPE2
                 PFA_ITYPE1:
000485 f0ba          .dw XT_DUP         ; ( -- addr addr )
000486 f3d7          .dw XT_FETCHI      ; ( -- addr c1c2 )
000487 f0ba          .dw XT_DUP
000488 049a          .dw XT_LOWEMIT
000489 0496          .dw XT_HIEMIT
00048a f244          .dw XT_1PLUS    ; ( -- addr+cell )
00048b f2ea          .dw XT_DOLOOP
00048c 0485          .dw PFA_ITYPE1
                 PFA_ITYPE2:
00048d f0f8          .dw XT_R_FROM
00048e f173          .dw XT_GREATERZERO
00048f f039          .dw XT_DOCONDBRANCH
000490 0494          .dw PFA_ITYPE3
000491 f0ba            .dw XT_DUP     ; make sure the drop below has always something to do
000492 f3d7            .dw XT_FETCHI
000493 049a            .dw XT_LOWEMIT
                 PFA_ITYPE3:
000494 f0e2          .dw XT_DROP
000495 f020          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
000496 f000          .dw DO_COLON
                 PFA_HIEMIT:
000497 f320          .dw XT_BYTESWAP
000498 049a          .dw XT_LOWEMIT
000499 f020          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
00049a f000          .dw DO_COLON
                 PFA_LOWEMIT:
00049b f040          .dw XT_DOLITERAL
00049c 00ff          .dw $00ff
00049d f228          .dw XT_AND
00049e 01d2          .dw XT_EMIT
00049f f020          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
0004a0 ff06          .dw $ff06
0004a1 6369
0004a2 756f
0004a3 746e          .db "icount"
0004a4 0475          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
0004a5 f000          .dw DO_COLON
                 PFA_ICOUNT:
0004a6 f0ba          .dw XT_DUP
0004a7 f244          .dw XT_1PLUS
0004a8 f0cd          .dw XT_SWAP
0004a9 f3d7          .dw XT_FETCHI
0004aa f020          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 VE_CR:
0004ab ff02          .dw $ff02
0004ac 7263          .db "cr"
0004ad 04a0          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
0004ae f000          .dw DO_COLON
                 PFA_CR:
0004af f040          .dw XT_DOLITERAL
0004b0 000d          .dw 13
0004b1 01d2          .dw XT_EMIT
0004b2 f040          .dw XT_DOLITERAL
0004b3 000a          .dw 10
0004b4 01d2          .dw XT_EMIT
0004b5 f020          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 VE_SPACE:
0004b6 ff05          .dw $ff05
0004b7 7073
0004b8 6361
0004b9 0065          .db "space",0
0004ba 04ab          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
0004bb f000          .dw DO_COLON
                 PFA_SPACE:
0004bc 0289          .dw XT_BL
0004bd 01d2          .dw XT_EMIT
0004be f020          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 VE_SPACES:
0004bf ff06          .dw $ff06
0004c0 7073
0004c1 6361
0004c2 7365          .db "spaces"
0004c3 04b6          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
0004c4 f000          .dw DO_COLON
                 PFA_SPACES:
0004c5 f0ba          .dw XT_DUP
0004c6 f173          .dw XT_GREATERZERO
0004c7 f228          .dw XT_AND
0004c8 f14b          .dw XT_ZERO
0004c9 f2b9          .dw XT_DOQDO
0004ca 04ce          .dw PFA_SPACES2
                 PFA_SPACES1:
0004cb 04bb          .dw XT_SPACE
0004cc f2ea          .dw XT_DOLOOP
0004cd 04cb          .dw PFA_SPACES1
                 PFA_SPACES2:
0004ce f020          .dw XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 VE_TYPE:
0004cf ff04          .dw $ff04
0004d0 7974
0004d1 6570          .db "type"
0004d2 04bf          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
0004d3 f000          .dw DO_COLON
                 PFA_TYPE:
0004d4 f0d8          .dw XT_OVER
0004d5 f1b2          .dw XT_PLUS
0004d6 f0cd          .dW XT_SWAP
0004d7 f2b9          .dw XT_DOQDO
0004d8 04de          .dw PFA_TYPE2
                 PFA_TYPE1:
0004d9 f2cf          .dw XT_I
0004da f0a1          .dw XT_CFETCH
0004db 01d2          .dw XT_EMIT
0004dc f2ea          .dw XT_DOLOOP
0004dd 04d9          .dw PFA_TYPE1
                 PFA_TYPE2:
0004de f020          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, returns XT or throw an exception -13
                 VE_TICK:
0004df ff01          .dw $ff01
0004e0 0027          .db "'",0
0004e1 04cf          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
0004e2 f000          .dw DO_COLON
                 PFA_TICK:
0004e3 06a2          .dw XT_PARSENAME
0004e4 06c0          .dw XT_FINDNAME
0004e5 f129          .dw XT_EQUALZERO
0004e6 f039          .dw XT_DOCONDBRANCH
0004e7 04eb          .dw PFA_TICK1
0004e8 f040          .dw XT_DOLITERAL
0004e9 fff3          .dw -13
0004ea 050f          .dw XT_THROW
                 PFA_TICK1:
0004eb f020          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 VE_HANDLER:
0004ec ff07          .dw $ff07
0004ed 6168
0004ee 646e
0004ef 656c
0004f0 0072          .db "handler",0
0004f1 04df          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
0004f2 f061          .dw PFA_DOUSER
                 PFA_HANDLER:
0004f3 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 VE_CATCH:
0004f4 ff05          .dw $ff05
0004f5 6163
0004f6 6374
0004f7 0068          .db "catch",0
0004f8 04ec          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
0004f9 f000          .dw DO_COLON
                 PFA_CATCH:
                     ; sp@ >r
0004fa f296          .dw XT_SP_FETCH
0004fb f101          .dw XT_TO_R
                     ; handler @ >r
0004fc 04f2          .dw XT_HANDLER
0004fd f082          .dw XT_FETCH
0004fe f101          .dw XT_TO_R
                     ; rp@ handler !
0004ff f27f          .dw XT_RP_FETCH
000500 04f2          .dw XT_HANDLER
000501 f08a          .dw XT_STORE
000502 f02a          .dw XT_EXECUTE
                     ; r> handler !
000503 f0f8          .dw XT_R_FROM
000504 04f2          .dw XT_HANDLER
000505 f08a          .dw XT_STORE
000506 f0f8          .dw XT_R_FROM
000507 f0e2          .dw XT_DROP
000508 f14b          .dw XT_ZERO
000509 f020          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 VE_THROW:
00050a ff05          .dw $ff05
00050b 6874
00050c 6f72
00050d 0077          .db "throw",0
00050e 04f4          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
00050f f000          .dw DO_COLON
                 PFA_THROW:
000510 f0ba          .dw XT_DUP
000511 f129          .dw XT_EQUALZERO
000512 f039          .dw XT_DOCONDBRANCH
000513 0516          .dw PFA_THROW1
000514 f0e2      	.dw XT_DROP
000515 f020      	.dw XT_EXIT
                 PFA_THROW1:
000516 04f2          .dw XT_HANDLER
000517 f082          .dw XT_FETCH
000518 f289          .dw XT_RP_STORE
000519 f0f8          .dw XT_R_FROM
00051a 04f2          .dw XT_HANDLER
00051b f08a          .dw XT_STORE
00051c f0f8          .dw XT_R_FROM
00051d f0cd          .dw XT_SWAP
00051e f101          .dw XT_TO_R
00051f f29f          .dw XT_SP_STORE
000520 f0e2          .dw XT_DROP
000521 f0f8          .dw XT_R_FROM    
000522 f020          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/char-skip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 VE_CSKIP:
000523 ff05          .dw $ff05
000524 7363
000525 696b
000526 0070          .db "cskip",0
000527 050a          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
000528 f000          .dw DO_COLON
                 PFA_CSKIP:
000529 f101          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
00052a f0ba          .dw XT_DUP            ; ( -- addr' n' n' )
00052b f039          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00052c 0538          .dw PFA_CSKIP2
00052d f0d8          .dw XT_OVER           ; ( -- addr' n' addr' )
00052e f0a1          .dw XT_CFETCH         ; ( -- addr' n' c' )
00052f f10a          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
000530 f11f          .dw XT_EQUAL          ; ( -- addr' n' f )
000531 f039          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000532 0538          .dw PFA_CSKIP2
000533 f040          .dw XT_DOLITERAL
000534 0001          .dw 1
000535 0691          .dw XT_SLASHSTRING
000536 f02f          .dw XT_DOBRANCH
000537 052a          .dw PFA_CSKIP1
                 PFA_CSKIP2:
000538 f0f8          .dw XT_R_FROM
000539 f0e2          .dw XT_DROP           ; ( -- addr2 n2)
00053a f020          .dw XT_EXIT
                 .include "words/accept.asm"
                 
                 ; System
                 ; receive a string of at most n1 characters at addr until n2 characters are reveived or cr/lf detected.
                 VE_ACCEPT:
00053b ff06          .dw $ff06
00053c 6361
00053d 6563
00053e 7470          .db "accept"
00053f 0523          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
000540 f000          .dw DO_COLON
                 PFA_ACCEPT:
000541 f0ba          .dw XT_DUP        ; ( -- addr n1 n1)
000542 f101          .dw XT_TO_R
000543 f101          .dw XT_TO_R
                 PFA_ACCEPT1:          ; ( -- addr )
000544 01e3          .dw XT_KEY        ; ( -- addr k )
000545 f0ba          .dw XT_DUP        ; ( -- addr k k )
000546 f040          .dw XT_DOLITERAL
000547 000a          .dw 10
000548 f115          .dw XT_NOTEQUAL
000549 f039          .dw XT_DOCONDBRANCH
00054a 057e          .dw PFA_ACCEPT2
00054b f0ba          .dw XT_DUP
00054c f040          .dw XT_DOLITERAL
00054d 000d          .dw 13
00054e f115          .dw XT_NOTEQUAL
00054f f039          .dw XT_DOCONDBRANCH
000550 057e          .dw PFA_ACCEPT2
                     ; check backspace
000551 f0ba          .dw XT_DUP
000552 f040          .dw XT_DOLITERAL
000553 0008          .dw 8
000554 f11f          .dw XT_EQUAL
000555 f039          .dw XT_DOCONDBRANCH
000556 056a          .dw PFA_ACCEPT3
                     ; delete previous character
                     ; check beginning of line
000557 f0f8          .dw XT_R_FROM             ; ( -- addr k n1 )
000558 f10a          .dw XT_R_FETCH            ; ( -- addr k n1 n2)
000559 f0d8          .dw XT_OVER               ; ( -- addr k n1 n2 n1)
00055a f101          .dw XT_TO_R
00055b f11f          .dw XT_EQUAL              ; ( -- addr k f )
00055c f039          .dw XT_DOCONDBRANCH
00055d 0561          .dw PFA_ACCEPT5
                     ; we are at the beginning of the line, ignore this character
00055e f0e2          .dw XT_DROP               ; ( -- addr )
00055f f02f          .dw XT_DOBRANCH
000560 0544          .dw PFA_ACCEPT1
                 PFA_ACCEPT5:
000561 f0ba          .dw XT_DUP                ; ( -- addr k k )
000562 01d2          .dw XT_EMIT               ; ( -- addr k )
000563 04bb          .dw XT_SPACE              ; ( -- addr k )
000564 01d2          .dw XT_EMIT               ; ( -- addr )
000565 f24a          .dw XT_1MINUS             ; ( -- addr--)
000566 f0f8          .dw XT_R_FROM
000567 f244          .dw XT_1PLUS
000568 f02f          .dw XT_DOBRANCH
000569 0578          .dw PFA_ACCEPT4
                 PFA_ACCEPT3:
                     ; check for remaining control characters, replace them with blank
00056a f0ba          .dw XT_DUP            ; ( -- addr k k )
00056b 0289          .dw XT_BL
00056c f12f          .dw XT_LESS
00056d f039          .dw XT_DOCONDBRANCH
00056e 0571          .dw PFA_ACCEPT6
00056f f0e2          .dw XT_DROP
000570 0289          .dw XT_BL
                 PFA_ACCEPT6:
                     ; emit the key
000571 f0ba          .dw XT_DUP            ; ( -- addr k k)
000572 01d2          .dw XT_EMIT           ; ( -- addr k)
                     ; now store the key
000573 f0d8          .dw XT_OVER           ; ( -- addr k addr
000574 f096          .dw XT_CSTORE         ; ( -- addr)
000575 f244          .dw XT_1PLUS          ; ( -- addr++)
000576 f0f8          .dw XT_R_FROM         ; ( -- addr n1)
000577 f24a          .dw XT_1MINUS         ; ( -- addr n1--)
                 PFA_ACCEPT4:
000578 f0ba          .dw XT_DUP
000579 f101          .dw XT_TO_R
00057a f129          .dw XT_EQUALZERO
00057b f039          .dw XT_DOCONDBRANCH
00057c 0544          .dw PFA_ACCEPT1
00057d f0ba          .dw XT_DUP
                 PFA_ACCEPT2:
00057e f0e2          .dw XT_DROP
00057f f0e2          .dw XT_DROP
000580 f0f8          .dw XT_R_FROM
000581 f0f8          .dw XT_R_FROM
000582 f0cd          .dw XT_SWAP
000583 f1a8          .dw XT_MINUS
000584 04ae          .dw XT_CR
000585 f020          .dw XT_EXIT
                 
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
000586 ff06          .dw $ff06
000587 6572
000588 6966
000589 6c6c          .db "refill"
00058a 053b          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
00058b 089d          .dw PFA_DODEFER
                 PFA_REFILL:
00058c 001a          .dw USER_REFILL
00058d 0875          .dw XT_UDEFERFETCH
00058e 087c          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 VE_CHAR:
00058f ff04          .dw $ff04
000590 6863
000591 7261          .db "char"
000592 0586          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
000593 f000          .dw DO_COLON
                 PFA_CHAR:
000594 06a2          .dw XT_PARSENAME
000595 f0e2          .dw XT_DROP
000596 f0a1          .dw XT_CFETCH
000597 f020          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 VE_NUMBER:
000598 ff06          .dw $ff06
000599 756e
00059a 626d
00059b 7265          .db "number"
00059c 058f          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
00059d f000          .dw DO_COLON
                 PFA_NUMBER:
00059e 01a5          .dw XT_BASE
00059f f082          .dw XT_FETCH
0005a0 f101          .dw XT_TO_R
0005a1 0610          .dw XT_NUMBERSIGN
0005a2 f101          .dw XT_TO_R
0005a3 05dc          .dw XT_PRAEFIX
0005a4 0610          .dw XT_NUMBERSIGN
0005a5 f0f8          .dw XT_R_FROM
0005a6 f231          .dw XT_OR
0005a7 f101          .dw XT_TO_R
0005a8 f101          .dw XT_TO_R
0005a9 f101          .dw XT_TO_R
0005aa f14b          .dw XT_ZERO       ; starting value
0005ab f14b          .dw XT_ZERO
0005ac f0f8          .dw XT_R_FROM
0005ad f0f8          .dw XT_R_FROM
0005ae 062f          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
0005af f0c2          .dw XT_QDUP
0005b0 f039              .dw XT_DOCONDBRANCH
0005b1 05cf      	.dw PFA_NUMBER1
                     ; if equal 1: mayba a trailing dot? --> double cell number
0005b2 f040          .dw XT_DOLITERAL
0005b3 0001          .dw 1
0005b4 f11f          .dw XT_EQUAL
0005b5 f039          .dw XT_DOCONDBRANCH
0005b6 05c5          .dw PFA_NUMBER2
                 	; excatly one character is left
0005b7 f0a1      	.dw XT_CFETCH
0005b8 f040      	.dw XT_DOLITERAL
0005b9 002e      	.dw $2e ; .
0005ba f11f      	.dw XT_EQUAL
0005bb f039      	.dw XT_DOCONDBRANCH
0005bc 05c5      	.dw PFA_NUMBER2
                 	; its a double cell number
                         ; incorporate sign into number
0005bd f0f8      	.dw XT_R_FROM
0005be f039              .dw XT_DOCONDBRANCH
0005bf 05c1      	.dw PFA_NUMBER3
0005c0 094f              .dw XT_DNEGATE
                 PFA_NUMBER3:
0005c1 f040      	.dw XT_DOLITERAL
0005c2 0002      	.dw 2
0005c3 f02f      	.dw XT_DOBRANCH
0005c4 05d7      	.dw PFA_NUMBER5
                 PFA_NUMBER2:
0005c5 f0e2      	.dw XT_DROP
0005c6 f0e2      	.dw XT_DROP
0005c7 f0e2      	.dw XT_DROP
0005c8 f0f8      	.dw XT_R_FROM
0005c9 f0e2      	.dw XT_DROP
0005ca f0f8              .dw XT_R_FROM
0005cb 01a5              .dw XT_BASE
0005cc f08a              .dw XT_STORE
0005cd f14b      	.dw XT_ZERO
0005ce f020      	.dw XT_EXIT
                 PFA_NUMBER1:
0005cf f0e2          .dw XT_DROP ; remove the address
0005d0 f0e2          .dw XT_DROP ; make it a single cell value
                     ; incorporate sign into number
0005d1 f0f8          .dw XT_R_FROM
0005d2 f039          .dw XT_DOCONDBRANCH
0005d3 05d5          .dw PFA_NUMBER4
0005d4 02ec          .dw XT_NEGATE
                 PFA_NUMBER4:
0005d5 f040          .dw XT_DOLITERAL
0005d6 0001          .dw 1
                 PFA_NUMBER5:
0005d7 f0f8          .dw XT_R_FROM
0005d8 01a5          .dw XT_BASE
0005d9 f08a          .dw XT_STORE
0005da f154          .dw XT_TRUE
0005db f020          .dw XT_EXIT
                 
                 ; ( addr len -- addr' len' ) 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 ;VE_PRAEFIX:
                 ;    .dw $FF07 
                 ;    .db "praefix",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PRAEFIX
                 XT_PRAEFIX:
0005dc f000          .dw DO_COLON 
                 PFA_PRAEFIX:        ; ( adr1 len1 -- adr2 len2 ) 
0005dd f0d8          .dw XT_OVER 
0005de f0a1          .dw XT_CFETCH 
0005df f040          .dw XT_DOLITERAL
0005e0 0029          .dw $29 
0005e1 f139          .dw XT_GREATER 
0005e2 f039          .dw XT_DOCONDBRANCH
0005e3 05e5          .dw PFA_PRAEFIX0 
0005e4 f020          .dw XT_EXIT 
                 PFA_PRAEFIX0:
0005e5 f0d8          .dw XT_OVER 
0005e6 f0a1          .dw XT_CFETCH 
0005e7 05ec          .dw XT_SETBASE
0005e8 f040          .dw XT_DOLITERAL
0005e9 0001          .dw $1 
0005ea 0691          .dw XT_SLASHSTRING 
0005eb f020          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_SETBASE:
0005ec f000          .dw DO_COLON 
                 PFA_SETBASE:        ; ( c -- ) 
0005ed f0ba          .dw XT_DUP 
0005ee f040          .dw XT_DOLITERAL
0005ef 0024          .dw '$' 
0005f0 f11f          .dw XT_EQUAL 
0005f1 f039          .dw XT_DOCONDBRANCH
0005f2 05f6          .dw PFA_SETBASE0 
0005f3 f0e2          .dw XT_DROP 
0005f4 0280          .dw XT_HEX 
0005f5 f020          .dw XT_EXIT 
                 PFA_SETBASE0:
0005f6 f0ba          .dw XT_DUP 
0005f7 f040          .dw XT_DOLITERAL
0005f8 0025          .dw '%' 
0005f9 f11f          .dw XT_EQUAL 
0005fa f039          .dw XT_DOCONDBRANCH
0005fb 05ff          .dw PFA_SETBASE1 
0005fc f0e2          .dw XT_DROP 
0005fd 026a          .dw XT_BIN
0005fe f020          .dw XT_EXIT 
                 PFA_SETBASE1:
0005ff f0ba          .dw XT_DUP 
000600 f040          .dw XT_DOLITERAL
000601 0026          .dw '&'
000602 f11f          .dw XT_EQUAL 
000603 f039          .dw XT_DOCONDBRANCH
000604 0608          .dw PFA_SETBASE2 
000605 f0e2          .dw XT_DROP
000606 0276          .dw XT_DECIMAL 
000607 f020          .dw XT_EXIT 
                 PFA_SETBASE2:        ; ( error) 
000608 f040          .dw XT_DOLITERAL
000609 0023          .dw '#'
00060a f11f          .dw XT_EQUAL 
00060b f039          .dw XT_DOCONDBRANCH
00060c 060f          .dw PFA_SETBASE3 
00060d 0276          .dw XT_DECIMAL 
00060e f020          .dw XT_EXIT 
                 PFA_SETBASE3:
00060f f020          .dw XT_EXIT 
                 
                 ; (c -- ) Numeric IO
                 ; R( -- )
                 ; set the BASE value depending on the character
                 ;VE_SETBASE:
                 ;    .dw $FF07 
                 ;    .db "setbase",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SETBASE
                 XT_NUMBERSIGN:
000610 f000          .dw DO_COLON 
                 PFA_NUMBERSIGN:        ; ( c -- ) 
000611 f0d8          .dw XT_OVER
000612 f0a1          .dw XT_CFETCH
000613 f040          .dw XT_DOLITERAL
000614 002b          .dw '+'
000615 f11f          .dw XT_EQUAL
000616 f039          .dw XT_DOCONDBRANCH
000617 061b          .dw PFA_NUMBERSIGN_MINUS
000618 f040            .dw XT_DOLITERAL
000619 0001            .dw 1
00061a 0691            .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_MINUS:
00061b f0d8          .dw XT_OVER    ; ( -- addr len addr )
00061c f0a1          .dw XT_CFETCH
00061d f040          .dw XT_DOLITERAL
00061e 002d          .dw '-'
00061f f11f          .dw XT_EQUAL  ; ( -- addr len flag )
000620 f0ba          .dw XT_DUP
000621 f101          .dw XT_TO_R
000622 f039          .dw XT_DOCONDBRANCH
000623 0627          .dw PFA_NUMBERSIGN_PLUS
000624 f040          .dw XT_DOLITERAL      ; skip sign character
000625 0001          .dw 1
000626 0691          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_PLUS:
000627 f0f8          .dw XT_R_FROM
000628 f020          .dw XT_EXIT
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 VE_TO_NUMBER:
000629 ff07          .dw $ff07
00062a 6e3e
00062b 6d75
00062c 6562
00062d 0072          .db ">number",0
00062e 0598          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
00062f f000          .dw DO_COLON
                 PFA_TO_NUMBER:
000630 f0ba          .dw XT_DUP
000631 f039          .dw XT_DOCONDBRANCH
000632 064d          .dw PFA_TO_NUMBER1
000633 f0d8              .dw XT_OVER
000634 f0a1              .dw XT_CFETCH
000635 040a              .dw XT_DIGITQ
000636 f129              .dw XT_EQUALZERO
000637 f039              .dw XT_DOCONDBRANCH
000638 063a              .dw PFA_TO_NUMBER2
000639 f020                  .dw XT_EXIT
                 PFA_TO_NUMBER2:
00063a f101              .dw XT_TO_R
00063b 0983              .dw XT_2SWAP
00063c f0f8              .dw XT_R_FROM
00063d f0cd              .dw XT_SWAP
00063e 01a5              .dw XT_BASE
00063f f082              .dw XT_FETCH
000640 f1f5              .dw XT_UMSTAR
000641 f0e2              .dw XT_DROP
000642 f0ea              .dw XT_ROT
000643 01a5              .dw XT_BASE
000644 f082              .dw XT_FETCH
000645 f1f5              .dw XT_UMSTAR
000646 0c89              .dw XT_DPLUS
000647 0983              .dw XT_2SWAP
000648 f040              .dw XT_DOLITERAL
000649 0001              .dw 1
00064a 0691              .dw XT_SLASHSTRING
00064b f02f          .dw XT_DOBRANCH
00064c 0630          .dw PFA_TO_NUMBER
                 PFA_TO_NUMBER1:
00064d f020          .dw XT_EXIT
                 
                 ;: >number  ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
                 ;  \ convert double number, leaving address of first unconverted byte
                 ;   begin  dup  while                  ( ud adr len )
                 ;      over c@  base @  digit          ( ud adr len  digit true  |  char false )
                 ;      0=  if  drop exit  then         ( ud adr len  digit )
                 ;      >r  2swap  r>                   ( adr len ud  digit )
                 ;      swap base @ um*  drop           ( adr len ud.low  digit ud.high' )
                 ;      rot base @ um*  d+              ( adr len  ud' )
                 ;      2swap  1 /string                ( ud' adr len )
                 ;   repeat                             ( ud' adr len )
                 ;;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 VE_PARSE:
00064e ff05          .dw $ff05
00064f 6170
000650 7372
000651 0065          .db "parse",0
000652 0629          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
000653 f000          .dw DO_COLON
                 PFA_PARSE:
000654 f101          .dw XT_TO_R     ; ( -- )
000655 0687          .dw XT_SOURCE   ; ( -- addr len)
000656 01bc          .dw XT_G_IN     ; ( -- addr len >in)
000657 f082          .dw XT_FETCH
000658 0691          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
000659 f0f8          .dw XT_R_FROM      ; ( -- addr' len' c)
00065a 0668          .dw XT_CSCAN       ; ( -- addr' len'')
00065b f0ba          .dw XT_DUP         ; ( -- addr' len'' len'')
00065c f244          .dw XT_1PLUS
00065d 01bc          .dw XT_G_IN        ; ( -- addr' len'' len'' >in)
00065e f26e          .dw XT_PLUSSTORE   ; ( -- addr' len')
00065f f040          .dw XT_DOLITERAL
000660 0001          .dw 1
000661 0691          .dw XT_SLASHSTRING
000662 f020          .dw XT_EXIT
                 .include "words/char-scan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 VE_CSCAN:
000663 ff05          .dw $ff05
000664 7363
000665 6163
000666 006e          .db "cscan",0
000667 064e          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
000668 f000          .dw DO_COLON
                 PFA_CSCAN:
000669 f0cd          .dw XT_SWAP         ; ( -- addr1 c n1 )
00066a f0ba          .dw XT_DUP          ; ( -- addr1 c n1 n1)
00066b f101          .dw XT_TO_R         ; ( -- addr1 c n1)
00066c f14b          .dw XT_ZERO         ; ( -- addr1 c n1 0)
00066d f2b9          .dw XT_DOQDO        ; ( -- addr1 c)
00066e 067f          .dw PFA_CSCAN3
                 PFA_CSCAN1:
00066f f0d8          .dw XT_OVER         ; ( -- addr1 c addr1 )
000670 f2cf          .dw XT_I            ; ( -- addr1 c addr1 i)
000671 f1b2          .dw XT_PLUS         ; ( -- addr1 c addr')
000672 f0a1          .dw XT_CFETCH       ; ( -- addr1 c c')
000673 f0d8          .dw XT_OVER         ; ( -- addr1 c c' c)
000674 f11f          .dw XT_EQUAL        ; ( -- addr1 c f)
000675 f039          .dw XT_DOCONDBRANCH ; ( -- addr1 c)
000676 067d          .dw PFA_CSCAN2
000677 f0e2          .dw XT_DROP         ; ( -- addr1 )
000678 f2cf          .dw XT_I            ; ( -- addr1 n2)
000679 f2f9          .dw XT_UNLOOP       ; ( -- addr1 n2)
00067a f0f8          .dw XT_R_FROM       ; ( -- addr1 n2 n1)
00067b f0e2          .dw XT_DROP         ; ( -- addr1 n2)
00067c f020          .dw XT_EXIT
                 PFA_CSCAN2:
00067d f2ea          .dw XT_DOLOOP
00067e 066f          .dw PFA_CSCAN1      ; ( -- addr1 c)
                 PFA_CSCAN3:
00067f f0e2          .dw XT_DROP         ; ( -- addr1)
000680 f0f8          .dw XT_R_FROM       ; ( -- addr1 n1)
000681 f020          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
000682 ff06          .dw $FF06
000683 6f73
000684 7275
000685 6563          .db "source"
000686 0663          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
000687 089d          .dw PFA_DODEFER
                 PFA_SOURCE:
000688 0016          .dw USER_SOURCE
000689 0875          .dw XT_UDEFERFETCH
00068a 087c          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slashstring.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 VE_SLASHSTRING:
00068b ff07          .dw $ff07
00068c 732f
00068d 7274
00068e 6e69
00068f 0067          .db "/string",0
000690 0682          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
000691 f000          .dw DO_COLON
                 PFA_SLASHSTRING:
000692 f0d8          .dw XT_OVER    ; ( -- addr1 u1 n u1)
000693 030f          .dw XT_MIN     ; ( -- addr1 u1 n|u1)
000694 f0ea          .dw XT_ROT     ; ( -- u1 n addr1 )
000695 f0d8          .dw XT_OVER    ; ( -- u1 n addr1 n)
000696 f1b2          .dw XT_PLUS    ; ( -- u1 n addr2 )
000697 f0ea          .dw XT_ROT     ; ( -- n addr2 u1)
000698 f0ea          .dw XT_ROT     ; ( -- addr2 u1 n)
000699 f1a8          .dw XT_MINUS   ; ( -- addr2 u2)
00069a f020          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 VE_PARSENAME:
00069b ff0a          .dw $FF0A 
00069c 6170
00069d 7372
00069e 2d65
00069f 616e
0006a0 656d          .db "parse-name"
0006a1 068b          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
0006a2 f000          .dw DO_COLON 
                 PFA_PARSENAME:
0006a3 0289          .dw XT_BL
0006a4 06a6          .dw XT_SKIPSCANCHAR
0006a5 f020          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
0006a6 f000          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
0006a7 f101          .dw XT_TO_R
0006a8 0687          .dw XT_SOURCE 
0006a9 01bc          .dw XT_G_IN 
0006aa f082          .dw XT_FETCH 
0006ab 0691          .dw XT_SLASHSTRING 
                 
0006ac f10a          .dw XT_R_FETCH
0006ad 0528          .dw XT_CSKIP
0006ae f0f8          .dw XT_R_FROM
0006af 0668          .dw XT_CSCAN
                 
                     ; adjust >IN
0006b0 f0d8          .dw XT_OVER
0006b1 f0d8          .dw XT_OVER     
0006b2 f1b2          .dw XT_PLUS     
0006b3 0687          .dw XT_SOURCE 
0006b4 f0e2          .dw XT_DROP     
0006b5 f1a8          .dw XT_MINUS 
0006b6 01bc          .dw XT_G_IN 
0006b7 f08a          .dw XT_STORE 
0006b8 f020          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for the name from string addr/len
                 VE_FINDNAME:
0006b9 ff09          .dw $ff09
0006ba 6966
0006bb 646e
0006bc 6e2d
0006bd 6d61
0006be 0065          .db "find-name",0
0006bf 069b          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
0006c0 f000          .dw DO_COLON
                 PFA_FINDNAME:
0006c1 f040          .dw XT_DOLITERAL
0006c2 0016          .dw EE_ORDERLISTLEN
0006c3 f365          .dw XT_FETCHE
0006c4 f14b          .dw XT_ZERO
0006c5 f2b9          .dw XT_DOQDO
0006c6 06dd          .dw PFA_FINDNAME2
                 PFA_FINDNAME1:
                     ; ( addr len --)
0006c7 f0d8          .dw XT_OVER
0006c8 f0d8          .dw XT_OVER
0006c9 f040          .dw XT_DOLITERAL
0006ca 0018          .dw EE_ORDERLIST
0006cb f2cf          .dw XT_I
0006cc 01ac          .dw XT_CELLS
0006cd f1b2          .dw XT_PLUS  
0006ce f365          .dw XT_FETCHE ; ( -- addr len addr len wid )
                 PFA_FINDNAME3:
0006cf 08b1          .dw XT_SEARCH_WORDLIST ; ( -- addr len [xt] flag
0006d0 f0c2          .dw XT_QDUP
0006d1 f039          .dw XT_DOCONDBRANCH
0006d2 06db          .dw PFA_FINDNAME4
0006d3 f101      	.dw XT_TO_R
0006d4 f101      	.dw XT_TO_R
0006d5 f0e2      	.dw XT_DROP
0006d6 f0e2      	.dw XT_DROP
0006d7 f0f8      	.dw XT_R_FROM
0006d8 f0f8      	.dw XT_R_FROM
0006d9 f2f9      	.dw XT_UNLOOP
0006da f020      	.dw XT_EXIT
                 PFA_FINDNAME4:
0006db f2ea          .dw XT_DOLOOP
0006dc 06c7          .dw PFA_FINDNAME1
                 PFA_FINDNAME2:
0006dd f0e2          .dw XT_DROP
0006de f0e2          .dw XT_DROP
0006df f14b          .dw XT_ZERO
0006e0 f020          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 VE_QUIT:
0006e1 ff04          .dw $ff04
0006e2 7571
0006e3 7469          .db "quit"
0006e4 06b9          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
0006e5 f000          .dw DO_COLON
                 PFA_QUIT:
0006e6 075d          .dw XT_SP0
0006e7 f29f          .dw XT_SP_STORE
0006e8 076a          .dw XT_RP0
0006e9 f289          .dw XT_RP_STORE
0006ea 0e9e          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
0006eb 019f          .dw XT_STATE
0006ec f082          .dw XT_FETCH
0006ed f129          .dw XT_EQUALZERO
0006ee f039          .dw XT_DOCONDBRANCH
0006ef 06f1          .dw PFA_QUIT4
0006f0 0707          .dw XT_PROMPTRDY
                 PFA_QUIT4:
0006f1 058b          .dw XT_REFILL
0006f2 f039          .dw XT_DOCONDBRANCH
0006f3 06eb          .dw PFA_QUIT2
0006f4 f040          .dw XT_DOLITERAL
0006f5 0783          .dw XT_INTERPRET
0006f6 04f9          .dw XT_CATCH
0006f7 f0c2          .dw XT_QDUP
0006f8 f039          .dw XT_DOCONDBRANCH
0006f9 0703          .dw PFA_QUIT3
0006fa f0ba      	.dw XT_DUP
0006fb f040      	.dw XT_DOLITERAL
0006fc fffe      	.dw -2
0006fd f12f      	.dw XT_LESS
0006fe f039      	.dw XT_DOCONDBRANCH
0006ff 0701      	.dw PFA_QUIT5
000700 0715      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
000701 f02f      	.dw XT_DOBRANCH
000702 06e6      	.dw PFA_QUIT
                 PFA_QUIT3:
000703 070e          .dw XT_PROMPTOK
000704 f02f          .dw XT_DOBRANCH
000705 06eb          .dw PFA_QUIT2
000706 f020          .dw XT_EXIT ; never reached
                 
                 .include "words/prompts.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_rd"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTRDY:
000707 f000          .dw DO_COLON
                 PFA_PROMPTRDY:
000708 04ae          .dw XT_CR
000709 0443          .dw XT_DOSLITERAL
00070a 0002          .dw 2
00070b 203e          .db "> "
00070c 047a          .dw XT_ITYPE
00070d f020          .dw XT_EXIT
                 
                 ; ( -- )
                 ; System
                 ; send the OK prompt to the command line
                 ;VE_PROMPTOK:
                 ;    .dw $ff04
                 ;    .db "p_ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
00070e f000          .dw DO_COLON
                 PFA_PROMPTOK:
00070f 0443          .dw XT_DOSLITERAL
000710 0003          .dw 3
000711 6f20
000712 006b          .db " ok",0
000713 047a          .dw XT_ITYPE
000714 f020          .dw XT_EXIT
                 
                 ; ( n -- ) 
                 ; System
                 ; process the error prompt
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
000715 f000          .dw DO_COLON
                 PFA_PROMPTERROR:
000716 0443      	.dw XT_DOSLITERAL
000717 0004      	.dw 4
000718 3f20
000719 203f      	.db  " ?? "
00071a 047a          .dw XT_ITYPE
00071b 01a5      	.dw XT_BASE
00071c f082      	.dw XT_FETCH
00071d f101      	.dw XT_TO_R
00071e 0276      	.dw XT_DECIMAL
00071f 03d9      	.dw XT_DOT
000720 01bc      	.dw XT_G_IN
000721 f082      	.dw XT_FETCH
000722 03d9      	.dw XT_DOT
000723 f0f8      	.dw XT_R_FROM
000724 01a5      	.dw XT_BASE
000725 f08a      	.dw XT_STORE
000726 f020          .dw XT_EXIT
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
000727 ff05          .dw $ff05
000728 6170
000729 7375
00072a 0065          .db "pause",0
00072b 06e1          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
00072c 089d          .dw PFA_DODEFER
                 PFA_PAUSE:
00072d 0291          .dw ram_pause
00072e 086b          .dw XT_RDEFERFETCH
00072f 0870          .dw XT_RDEFERSTORE
                 
                 .dseg
000291           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
000730 ff04          .dw $ff04
000731 6f63
000732 646c          .db "cold"
000733 0727          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
000734 0735          .dw PFA_COLD
                 PFA_COLD:
000735 b6a4          in_ r10, MCUSR
000736 24bb          clr r11
000737 2422          clr zerol
000738 2433          clr zeroh
000739 be24          out_ MCUSR, zerol
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000293           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
00073a e9e3          ldi zl, low(ram_user1)
00073b e0f2          ldi zh, high(ram_user1)
00073c 012f          movw upl, zl
                     ; init return stack pointer
00073d ef0f          ldi temp0,low(rstackstart)
00073e bf0d          out_ SPL,temp0
00073f 8304          std Z+4, temp0
000740 e211          ldi temp1,high(rstackstart)
000741 bf1e          out_ SPH,temp1
000742 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
000743 eacf          ldi yl,low(stackstart)
000744 83c6          std Z+6, yl
000745 e2d1          ldi yh,high(stackstart)
000746 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
000747 e5a0          ldi XL, low(PFA_WARM)
000748 e0b7          ldi XH, high(PFA_WARM)
                     ; its a far jump...
000749 940c f004     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
00074b ff04          .dw $ff04
00074c 6177
00074d 6d72          .db "warm"
00074e 0730          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
00074f f000          .dw DO_COLON
                 PFA_WARM:
000750 09d4          .dw XT_INITUSER
000751 f040          .dw XT_DOLITERAL
000752 0820          .dw XT_NOOP
000753 f040          .dw XT_DOLITERAL
000754 072c          .dw XT_PAUSE
000755 0888          .dw XT_DEFERSTORE
000756 0291          .dw XT_TURNKEY
000757 06e5          .dw XT_QUIT
000758 f020          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
000759 ff03          .dw $ff03
00075a 7073
00075b 0030          .db "sp0",0
00075c 074b          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
00075d f076          .dw PFA_DOVALUE
                 PFA_SP0:
00075e 0006          .dw USER_SP0
00075f f0a9          .dw XT_FETCHU
000760 f0b1          .dw XT_STOREU
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
000761 ff02          .dw $ff02
000762 7073          .db "sp"
000763 0759          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
000764 f061          .dw PFA_DOUSER
                 PFA_SP:
000765 0008          .dw USER_SP
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
000766 ff03          .dw $ff03
000767 7072
000768 0030          .db "rp0",0
000769 0761          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
00076a f000          .dw DO_COLON
                 PFA_RP0:
00076b 076e          .dw XT_DORP0
00076c f082          .dw XT_FETCH
00076d f020          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
00076e f061          .dw PFA_DOUSER
                 PFA_DORP0:
00076f 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 VE_DEPTH:
000770 ff05          .dw $ff05
000771 6564
000772 7470
000773 0068          .db "depth",0
000774 0766          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
000775 f000          .dw DO_COLON
                 PFA_DEPTH:
000776 075d          .dw XT_SP0
000777 f296          .dw XT_SP_FETCH
000778 f1a8          .dw XT_MINUS
000779 f219          .dw XT_2SLASH
00077a f24a          .dw XT_1MINUS
00077b f020          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; interpret input word by word.
                 VE_INTERPRET:
00077c ff09          .dw $ff09
00077d 6e69
00077e 6574
00077f 7072
000780 6572
000781 0074          .db "interpret",0
000782 0770          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
000783 f000          .dw DO_COLON
                 PFA_INTERPRET:
                 PFA_INTERPRET1:
000784 06a2          .dw XT_PARSENAME ; ( -- addr len )
000785 f0c2          .dw XT_QDUP   ; ( -- addr len len )
000786 f173          .dw XT_GREATERZERO
000787 f039          .dw XT_DOCONDBRANCH
000788 07a9          .dw PFA_INTERPRET5
000789 f040          .dw XT_DOLITERAL
00078a 0044          .dw EE_RECOGNIZERLISTLEN
00078b f365          .dw XT_FETCHE       ; ( addr len rec # -- )
00078c f14b          .dw XT_ZERO
                 
00078d f2b9          .dw XT_DOQDO
00078e 07a4          .dw PFA_INTERPRET4
                 PFA_INTERPRET2:
                     ; ( -- addr len )
                     ; I comes from the return stack.
00078f f0d8          .dw XT_OVER ; ( -- addr len addr )
000790 f0d8          .dw XT_OVER ; ( -- addr len addr len  )
000791 f2cf          .dw XT_I    ; ( -- addr len addr len i )
000792 f0ea          .dw XT_ROT  ; ( -- addr len len i addr )
000793 f0ea          .dw XT_ROT  ; ( -- addr len i addr len )
000794 f101          .dw XT_TO_R
000795 f101          .dw XT_TO_R
                 
000796 01ac          .dw XT_CELLS
000797 f040          .dw XT_DOLITERAL
000798 0046          .dw EE_RECOGNIZERLIST
000799 f1b2          .dw XT_PLUS
00079a f365          .dw XT_FETCHE
                 
00079b f02a          .dw XT_EXECUTE
00079c f0f8          .dw XT_R_FROM
00079d f0f8          .dw XT_R_FROM
00079e f0ea          .dw XT_ROT
00079f f039          .dw XT_DOCONDBRANCH
0007a0 07a2          .dw PFA_INTERPRET3
0007a1 0dfa            .dw XT_LEAVE
                 PFA_INTERPRET3:
0007a2 f2ea          .dw XT_DOLOOP
0007a3 078f          .dw PFA_INTERPRET2
                 PFA_INTERPRET4:
0007a4 f0e2          .dw XT_DROP
0007a5 f0e2          .dw XT_DROP
0007a6 07f6          .dw XT_QSTACK
0007a7 f02f          .dw XT_DOBRANCH
0007a8 0784          .dw PFA_INTERPRET1
                 PFA_INTERPRET5:
0007a9 f0e2          .dw xT_DROP
0007aa f020          .dw XT_EXIT
                 
                 .include "words/rec-intnumber.asm"
                 
                 ; Interpreter
                 ; recognizer for integer numbers
                 VE_REC_INTNUMBER:
0007ab ff0a          .dw $ff0a
0007ac 6572
0007ad 2d63
0007ae 6e69
0007af 6e74
0007b0 6d75          .db "rec-intnum"
0007b1 077c          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_INTNUMBER
                 XT_REC_INTNUMBER:
0007b2 f000          .dw DO_COLON
                 PFA_REC_INTNUMBER:
                     ; try converting to a number
0007b3 059d          .dw XT_NUMBER 
0007b4 f039          .dw XT_DOCONDBRANCH 
0007b5 07c7          .dw PFA_REC_NONUMBER
                 
0007b6 019f          .dw XT_STATE
0007b7 f082          .dw XT_FETCH
0007b8 f039          .dw XT_DOCONDBRANCH
0007b9 07c4          .dw PFA_REC_NUMBER_DONE
0007ba f040      	.dw XT_DOLITERAL
0007bb 0002      	.dw 2
0007bc f11f      	.dw XT_EQUAL
0007bd f039      	.dw XT_DOCONDBRANCH
0007be 07c1      	.dw PFA_REC_NUMBER_SINGLE
0007bf f0cd      	.dw XT_SWAP
0007c0 0d61              .dw XT_LITERAL
                 PFA_REC_NUMBER_SINGLE:
0007c1 0d61              .dw XT_LITERAL
0007c2 f02f              .dw XT_DOBRANCH
0007c3 07c5              .dw PFA_REC_NUMBER_OK
                 PFA_REC_NUMBER_DONE:
0007c4 f0e2          .dw XT_DROP
                 PFA_REC_NUMBER_OK:
0007c5 f154          .dw XT_TRUE
0007c6 f020          .dw XT_EXIT
                 PFA_REC_NONUMBER:
0007c7 f14b          .dw XT_ZERO
0007c8 f020          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; recognizer searching the dictionary
                 VE_REC_FIND:
0007c9 ff08          .dw $ff08
0007ca 6572
0007cb 2d63
0007cc 6966
0007cd 646e          .db "rec-find"
0007ce 07ab          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
0007cf f000          .dw DO_COLON
                 PFA_REC_FIND:
0007d0 06c0          .dw XT_FINDNAME
0007d1 f0ba          .dw XT_DUP
0007d2 f039          .dw XT_DOCONDBRANCH 
0007d3 07e2          .dw PFA_REC_FIND_NOTFOUND
                 	; either compile or execute the XT
0007d4 f173      	.dw XT_GREATERZERO
0007d5 f039      	.dw XT_DOCONDBRANCH
0007d6 07d9      	.dw PFA_REC_FIND_CHECKSTATE
                 	    ; flag is 1: always execute
0007d7 f02f      	    .dw XT_DOBRANCH
0007d8 07e0      	    .dw PFA_REC_FIND_EXECUTE
                 PFA_REC_FIND_CHECKSTATE:
                         ; check state 
0007d9 019f      	    .dw XT_STATE
0007da f082      	    .dw XT_FETCH
0007db f039      	    .dw XT_DOCONDBRANCH
0007dc 07e0      	    .dw PFA_REC_FIND_EXECUTE
0007dd 0254      	    .dw XT_COMMA
0007de f02f      	    .dw XT_DOBRANCH
0007df 07e1      	    .dw PFA_REC_FIND_OK
                 PFA_REC_FIND_EXECUTE:
                     ; state is zero, execute xt
0007e0 f02a          .dw XT_EXECUTE
                 PFA_REC_FIND_OK:
0007e1 f154          .dw XT_TRUE
                 PFA_REC_FIND_NOTFOUND:
0007e2 f020          .dw XT_EXIT
                 
                 .include "words/rec-notfound.asm"
                 
                 ; Interpreter
                 ; recognizer for NOT FOUND
                 VE_REC_NOTFOUND:
0007e3 ff0c          .dw $ff0c
0007e4 6572
0007e5 2d63
0007e6 6f6e
0007e7 6674
0007e8 756f
0007e9 646e          .db "rec-notfound"
0007ea 07c9          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NOTFOUND
                 XT_REC_NOTFOUND:
0007eb f000          .dw DO_COLON
                 PFA_REC_NOTFOUND:
0007ec 04d3          .dw XT_TYPE
0007ed f040          .dw XT_DOLITERAL
0007ee fff3          .dw -13
0007ef 050f          .dw XT_THROW
0007f0 f020          .dw XT_EXIT
                 
                 .include "words/qstack.asm"
                 
                 ; Tools
                 ; check stack underflow, throw exception -4
                 VE_QSTACK:
0007f1 ff06          .dw $ff06
0007f2 733f
0007f3 6174
0007f4 6b63          .db "?stack"
0007f5 07e3          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
0007f6 f000          .dw DO_COLON
                 PFA_QSTACK:
                 ; : ?stack ( -- )
                 ;    depth 0< if -&4 throw then
                 ; ;
0007f7 0775          .dw XT_DEPTH
0007f8 f144          .dw XT_LESSZERO
0007f9 f039          .dw XT_DOCONDBRANCH
0007fa 07fe          .dw PFA_QSTACK1
0007fb f040            .dw XT_DOLITERAL
0007fc fffc            .dw -4
0007fd 050f            .dw XT_THROW
                 PFA_QSTACK1:
0007fe f020          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 VE_VER:
0007ff ff03          .dw $ff03
000800 6576
000801 0072          .db "ver",0
000802 07f1          .dw VE_HEAD
                     .set VE_HEAD = VE_VER
                 XT_VER:
000803 f000          .dw DO_COLON
                 PFA_VER:
000804 0f55          .dw XT_ENV_FORTHNAME
000805 047a          .dw XT_ITYPE
000806 04bb          .dw XT_SPACE
000807 01a5          .dw XT_BASE
000808 f082          .dw XT_FETCH
000809 f101          .dw XT_TO_R
00080a 0276          .dw XT_DECIMAL
                 
00080b 0f63          .dw XT_ENV_FORTHVERSION
00080c f33b          .dw XT_S2D
00080d 0371          .dw XT_L_SHARP
00080e 0379          .dw XT_SHARP
00080f f040          .dw XT_DOLITERAL
000810 002e          .dw '.'
000811 0362          .dw XT_HOLD
000812 038f          .dw XT_SHARP_S
000813 039b          .dw XT_SHARP_G
000814 f0f8          .dw XT_R_FROM
000815 01a5          .dw XT_BASE
000816 f08a          .dw XT_STORE
                 
000817 04d3          .dw XT_TYPE
000818 04bb          .dw XT_SPACE
000819 0f6b          .dw XT_ENV_CPU
00081a 047a          .dw XT_ITYPE
00081b f020          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
00081c ff04          .dw $ff04
00081d 6f6e
00081e 706f          .db "noop"
00081f 07ff          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
000820 0821          .dw PFA_NOOP
                 PFA_NOOP:
000821 940c f004     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
000823 ff06          .dw $ff06
000824 6e75
000825 7375
000826 6465          .db "unused"
000827 081c          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
000828 f000          .dw DO_COLON
                 PFA_UNUSED:
000829 075d          .dw XT_SP0
00082a 0202          .dw XT_HERE
00082b f1a8          .dw XT_MINUS
00082c f020          .dw XT_EXIT
                 
                 .include "words/value.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a value and allocate 1 cell in EEPROM.
                 VE_VALUE:
00082d ff05          .dw $ff05
00082e 6176
00082f 756c
000830 0065          .db "value",0
000831 0823          .dw VE_HEAD
                     .set VE_HEAD = VE_VALUE
                 XT_VALUE:
000832 f000          .dw DO_COLON
                 PFA_VALUE:
000833 0217          .dw XT_DOCREATE
000834 0e37          .dw XT_REVEAL
                 
000835 0249          .dw XT_COMPILE
000836 f076          .dw PFA_DOVALUE
000837 01fa          .dw XT_EDP
000838 f0ba          .dw XT_DUP
000839 0254          .dw XT_COMMA
00083a f0ba          .dw XT_DUP
00083b f244          .dw XT_1PLUS
00083c f244          .dw XT_1PLUS
00083d 0853          .dw XT_DOTO
00083e 01fb          .dw PFA_EDP
00083f f349          .dw XT_STOREE
000840 0249          .dw XT_COMPILE
000841 f365          .dw XT_FETCHE
000842 0249          .dw XT_COMPILE
000843 f349          .dw XT_STOREE
000844 f020          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 VE_TO:
000845 0002          .dw $0002
000846 6f74          .db "to"
000847 082d          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
000848 f000          .dw DO_COLON
                 PFA_TO:
000849 04e2          .dw XT_TICK
00084a f244          .dw XT_1PLUS  		; to body
00084b 019f          .dw XT_STATE
00084c f082          .dw XT_FETCH
00084d f039          .dw XT_DOCONDBRANCH
00084e 0859          .dw PFA_TO1
00084f 0249          .dw XT_COMPILE
000850 0853          .dw XT_DOTO
000851 0254          .dw XT_COMMA
000852 f020          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 XT_DOTO:
000853 f000          .dw DO_COLON
                 PFA_DOTO:
000854 f0f8          .dw XT_R_FROM
000855 f0ba          .dw XT_DUP
000856 f244          .dw XT_1PLUS
000857 f101          .dw XT_TO_R
000858 f3d7          .dw XT_FETCHI
                 PFA_TO1:
000859 f0ba          .dw XT_DUP
00085a f3d7          .dw XT_FETCHI
00085b f0cd          .dw XT_SWAP
00085c f244          .dw XT_1PLUS
00085d f244          .dw XT_1PLUS
00085e f3d7          .dw XT_FETCHI
00085f f02a          .dw XT_EXECUTE
000860 f020          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 ;VE_EDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Edefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
000861 f000          .dw DO_COLON
                 PFA_EDEFERFETCH:
000862 f244          .dw XT_1PLUS ; >body
000863 f3d7          .dw XT_FETCHI
000864 f365          .dw XT_FETCHE
000865 f020          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 ;VE_EDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Edefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
000866 f000          .dw DO_COLON
                 PFA_EDEFERSTORE:
000867 f244          .dw XT_1PLUS
000868 f3d7          .dw XT_FETCHI
000869 f349          .dw XT_STOREE
00086a f020          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; Systemm
                 ; does the real defer@ for ram defers
                 ;VE_RDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Rdefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
00086b f000          .dw DO_COLON
                 PFA_RDEFERFETCH:
00086c f244          .dw XT_1PLUS ; >body
00086d f3d7          .dw XT_FETCHI
00086e f082          .dw XT_FETCH
00086f f020          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; does the real defer! for ram defers
                 ;VE_RDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Rdefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
000870 f000          .dw DO_COLON
                 PFA_RDEFERSTORE:
000871 f244          .dw XT_1PLUS
000872 f3d7          .dw XT_FETCHI
000873 f08a          .dw XT_STORE
000874 f020          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 ;VE_UDEFERFETCH:
                 ;    .dw $ff07
                 ;    .db "Udefer@"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
000875 f000          .dw DO_COLON
                 PFA_UDEFERFETCH:
000876 f244          .dw XT_1PLUS ; >body
000877 f3d7          .dw XT_FETCHI
000878 f329          .dw XT_UP_FETCH
000879 f1b2          .dw XT_PLUS
00087a f082          .dw XT_FETCH
00087b f020          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 ;VE_UDEFERSTORE:
                 ;    .dw $ff07
                 ;    .db "Udefer!"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
00087c f000          .dw DO_COLON
                 PFA_UDEFERSTORE:
00087d f244          .dw XT_1PLUS
00087e f3d7          .dw XT_FETCHI
00087f f329          .dw XT_UP_FETCH
000880 f1b2          .dw XT_PLUS
000881 f08a          .dw XT_STORE
000882 f020          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 VE_DEFERSTORE:
000883 ff06          .dw $ff06
000884 6564
000885 6566
000886 2172          .db "defer!"
000887 0845          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
000888 f000          .dw DO_COLON
                 PFA_DEFERSTORE:
000889 f0ba          .dw XT_DUP
00088a f040          .dw XT_DOLITERAL
00088b 0003          .dw 3
00088c f1b2          .dw XT_PLUS   ; >body 2 +
00088d f3d7          .dw XT_FETCHI
00088e f02a          .dw XT_EXECUTE
00088f f020          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 VE_DEFERFETCH:
000890 ff06          .dw $ff06
000891 6564
000892 6566
000893 4072          .db "defer@"
000894 0883          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
000895 f000          .dw DO_COLON
                 PFA_DEFERFETCH:
000896 f0ba          .dw XT_DUP
000897 f244          .dw XT_1PLUS ; >body
000898 f244          .dw XT_1PLUS 
000899 f3d7          .dw XT_FETCHI
00089a f02a          .dw XT_EXECUTE
00089b f020          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 ;VE_DOEDEFER:
                 ;    .dw $ff0a
                 ;    .db "(defer)", 0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOEDEFER
                 XT_DODEFER:
00089c 089d          .dw PFA_DODEFER
                 PFA_DODEFER:
00089d 940e 0e5b     call_ DO_DODOES
00089f f0ba          .dw XT_DUP
0008a0 f24a          .dw XT_1MINUS
0008a1 f0cd          .dw XT_SWAP
0008a2 f244          .dw XT_1PLUS
0008a3 f3d7          .dw XT_FETCHI
0008a4 f02a          .dw XT_EXECUTE 
0008a5 f02a          .dw XT_EXECUTE
0008a6 f020          .dw XT_EXIT
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 VE_SEARCH_WORDLIST:
0008a7 ff0f          .dw $ff0f
0008a8 6573
0008a9 7261
0008aa 6863
0008ab 772d
0008ac 726f
0008ad 6c64
0008ae 7369
0008af 0074          .db "search-wordlist",0
0008b0 0890          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
0008b1 f000          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
0008b2 f365          .dw XT_FETCHE
                 PFA_SEARCH_WORDLIST0:
0008b3 f0ba          .dw XT_DUP
0008b4 f129          .dw XT_EQUALZERO
0008b5 f039          .dw XT_DOCONDBRANCH
0008b6 08bc          .dw PFA_SEARCH_WORDLIST1
                       ; terminating 0 found
0008b7 f0e2            .dw XT_DROP
0008b8 f0e2            .dw XT_DROP
0008b9 f0e2            .dw XT_DROP
0008ba f14b            .dw XT_ZERO
0008bb f020            .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                     ; ( c-addr len searchstart )
0008bc f101          .dw XT_TO_R
0008bd f0d8          .dw XT_OVER
0008be f0d8          .dw XT_OVER
0008bf f10a          .dw XT_R_FETCH
0008c0 04a5          .dw XT_ICOUNT
0008c1 f040          .dw XT_DOLITERAL
0008c2 00ff          .dw $00ff
0008c3 f228          .dw XT_AND
0008c4 08e2          .dw XT_ICOMPARE
0008c5 f039          .dw XT_DOCONDBRANCH
0008c6 08d7          .dw PFA_SEARCH_WORDLISTNEXT
                       ; we found the string
0008c7 f0e2            .dw XT_DROP
0008c8 f0e2            .dw XT_DROP
0008c9 f0f8            .dw XT_R_FROM ; ( -- iaddr )
0008ca f0ba            .dw XT_DUP
0008cb f3d7            .dw XT_FETCHI
0008cc f101            .dw XT_TO_R
0008cd 0ff8            .dw XT_NFA2LFA
0008ce f244            .dw XT_1PLUS  ; lfa2xt
0008cf f040            .dw XT_DOLITERAL
0008d0 0001            .dw 1
0008d1 f0f8            .dw XT_R_FROM ; check flags
0008d2 f144            .dw XT_LESSZERO ; change here for multiple flags in header
0008d3 f039            .dw XT_DOCONDBRANCH
0008d4 08d6            .dw PFA_SEARCH_WORDLISTIMMEDIATE
0008d5 02ec            .dw XT_NEGATE
                 PFA_SEARCH_WORDLISTIMMEDIATE:
0008d6 f020            .dw XT_EXIT
                 PFA_SEARCH_WORDLISTNEXT:
                       ; next try
0008d7 f0f8            .dw XT_R_FROM
0008d8 0ff8            .dw XT_NFA2LFA
0008d9 f3d7            .dw XT_FETCHI
0008da f02f            .dw XT_DOBRANCH
0008db 08b3            .dw PFA_SEARCH_WORDLIST0
                 
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash
                 VE_ICOMPARE:
0008dc ff08          .dw $ff08
0008dd 6369
0008de 6d6f
0008df 6170
0008e0 6572          .db "icompare"
0008e1 08a7          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
0008e2 f000          .dw DO_COLON
                 PFA_ICOMPARE:
0008e3 f101          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
0008e4 f0d8          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
0008e5 f0f8          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
0008e6 f115          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
0008e7 f039          .dw XT_DOCONDBRANCH
0008e8 08ee          .dw PFA_ICOMPARE_SAMELEN
0008e9 f0e2            .dw XT_DROP
0008ea f0e2            .dw XT_DROP
0008eb f0e2            .dw XT_DROP
0008ec f14b            .dw XT_ZERO
0008ed f020            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
0008ee f0cd          .dw XT_SWAP ; ( -- r-addr f-addr len )
0008ef f14b          .dw XT_ZERO
0008f0 f2b9          .dw XT_DOQDO
0008f1 0912          .dw PFA_ICOMPARE_DONE
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
0008f2 f0d8          .dw XT_OVER
0008f3 f082          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
0008f4 0917          .dw XT_ICOMPARE_LC
                 .endif
0008f5 f0d8          .dw XT_OVER
0008f6 f3d7          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
0008f7 0917          .dw XT_ICOMPARE_LC
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
0008f8 f0ba          .dw XT_DUP
                     ;.dw XT_BYTESWAP
0008f9 f040          .dw XT_DOLITERAL
0008fa 0100          .dw $100
0008fb f12f          .dw XT_LESS
0008fc f039          .dw XT_DOCONDBRANCH
0008fd 0902          .dw PFA_ICOMPARE_LASTCELL
0008fe f0cd          .dw XT_SWAP
0008ff f040          .dw XT_DOLITERAL
000900 00ff          .dw $00FF
000901 f228          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
000902 f115          .dw XT_NOTEQUAL
000903 f039          .dw XT_DOCONDBRANCH
000904 090a          .dw PFA_ICOMPARE_NEXTLOOP
000905 f0e2          .dw XT_DROP
000906 f0e2          .dw XT_DROP
000907 f14b          .dw XT_ZERO
000908 f2f9          .dw XT_UNLOOP
000909 f020          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
00090a f244          .dw XT_1PLUS
00090b f0cd          .dw XT_SWAP
00090c 01b4          .dw XT_CELLPLUS
00090d f0cd          .dw XT_SWAP
00090e f040          .dw XT_DOLITERAL
00090f 0002          .dw 2
000910 f2d0          .dw XT_DOPLUSLOOP
000911 08f2          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
000912 f0e2          .dw XT_DROP
000913 f0e2          .dw XT_DROP
000914 f040          .dw XT_DOLITERAL
000915 ffff          .dw -1
000916 f020          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 ; ( cc1 cc2 -- f) 
                 ; Tools
                 ; compares two packed characters 
                 ;VE_ICOMPARELC:
                 ;    .dw $ff08
                 ;    .db "icompare-lower"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ICOMPARELC
                 XT_ICOMPARE_LC:
000917 f000          .dw DO_COLON
                 PFA_ICOMPARE_LC:
000918 f0ba          .dw XT_DUP
000919 f040          .dw XT_DOLITERAL
00091a 00ff          .dw $00ff
00091b f228          .dw XT_AND
00091c 034b          .dw XT_TOLOWER
00091d f0cd          .dw XT_SWAP
00091e f320          .dw XT_BYTESWAP
00091f f040          .dw XT_DOLITERAL
000920 00ff          .dw $00ff
000921 f228          .dw XT_AND
000922 034b          .dw XT_TOLOWER
000923 f320          .dw XT_BYTESWAP
000924 f231          .dw XT_OR
000925 f020          .dw XT_EXIT
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 VE_STAR:
000926 ff01          .dw $ff01
000927 002a          .db "*",0
000928 08dc          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
000929 f000          .dw DO_COLON
                 PFA_STAR:
00092a f1bb          .dw XT_MSTAR
00092b 093b          .dw XT_D2S
00092c f020          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
00092d ff01          .dw $FF01
00092e 006a          .db "j",0
00092f 0926          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
000930 f000          .dw DO_COLON
                 PFA_J:
000931 f27f          .dw XT_RP_FETCH
000932 f040          .dw XT_DOLITERAL
000933 0009          .dw 9
000934 f1b2          .dw XT_PLUS
000935 f082          .dw XT_FETCH
000936 f020          .dw XT_EXIT
                 
                 .include "words/d_to_s.asm"
                 
                 ; Conversion
                 ; shrink double cell value to single cell. 
                 VE_D2S:
000937 ff03          .dw $ff03
000938 3e64
000939 0073          .db "d>s",0
00093a 092d          .dw VE_HEAD
                     .set VE_HEAD = VE_D2S
                 XT_D2S:
00093b f000          .dw DO_COLON
                 PFA_D2S:
00093c f0e2          .dw XT_DROP
00093d f020          .dw XT_EXIT
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
00093e ff04          .dw $ff04
00093f 6164
000940 7362          .db "dabs"
000941 0937          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
000942 f000          .dw DO_COLON
                 PFA_DABS:
000943 f0ba          .dw XT_DUP
000944 f144          .dw XT_LESSZERO
000945 f039          .dw XT_DOCONDBRANCH
000946 0948          .dw PFA_DABS1
000947 094f          .dw XT_DNEGATE
                 PFA_DABS1:
000948 f020          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
000949 ff07          .dw $ff07
00094a 6e64
00094b 6765
00094c 7461
00094d 0065          .db "dnegate",0
00094e 093e          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
00094f f000          .dw DO_COLON
                 PFA_DNEGATE:
000950 0cb1          .dw XT_DINVERT
000951 f040          .dw XT_DOLITERAL
000952 0001          .dw 1
000953 f14b          .dw XT_ZERO
000954 0c89          .dw XT_DPLUS
000955 f020          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
000956 ff05          .dw $ff05
000957 6d63
000958 766f
000959 0065          .db "cmove",0
00095a 0949          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
00095b 095c          .dw PFA_CMOVE
                 PFA_CMOVE:
00095c 93bf          push xh
00095d 93af          push xl
00095e 91e9          ld zl, Y+
00095f 91f9          ld zh, Y+ ; addr-to
000960 91a9          ld xl, Y+
000961 91b9          ld xh, Y+ ; addr-from
000962 2f09          mov temp0, tosh
000963 2b08          or temp0, tosl
000964 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
000965 911d          ld temp1, X+
000966 9311          st Z+, temp1
000967 9701          sbiw tosl, 1
000968 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
000969 91af          pop xl
00096a 91bf          pop xh
00096b 9189
00096c 9199          loadtos
00096d 940c f004     jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
00096f ff03          .dw $ff03
000970 3264
000971 002f          .db "d2/",0
000972 0956          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
000973 0974          .dw PFA_D2SLASH
                 PFA_D2SLASH:
000974 9109          ld temp0, Y+
000975 9119          ld temp1, Y+
000976 9595          asr tosh
000977 9587          ror tosl
000978 9517          ror temp1
000979 9507          ror temp0
00097a 931a          st -Y, temp1
00097b 930a          st -Y, temp0
00097c 940c f004     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 VE_2SWAP:
00097e ff05          .dw $ff05
00097f 7332
000980 6177
000981 0070          .db "2swap",0
000982 096f          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
000983 f000          .dw DO_COLON
                 PFA_2SWAP:
000984 f0ea          .dw XT_ROT
000985 f101          .dw XT_TO_R
000986 f0ea          .dw XT_ROT
000987 f0f8          .dw XT_R_FROM
000988 f020          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
000989 ff03          .dw $ff03
00098a 6974
00098b 0062          .db "tib",0
00098c 097e          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
00098d f04e          .dw PFA_DOVARIABLE
                 PFA_TIB:
00098e 02b9          .dw ram_tib
                     
                 .dseg
0002b9           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
00098f ff0a          .dw $ff0a
000990 6572
000991 6966
000992 6c6c
000993 742d
000994 6269          .db "refill-tib"
000995 0989          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
000996 f000          .dw DO_COLON
                 PFA_REFILLTIB:
000997 098d          .dw XT_TIB
000998 f040          .dw XT_DOLITERAL
000999 0064          .dw TIBSIZE
00099a 0540          .dw XT_ACCEPT
00099b 01c2          .dw XT_NUMBERTIB
00099c f08a          .dw XT_STORE
00099d f14b          .dw XT_ZERO
00099e 01bc          .dw XT_G_IN
00099f f08a          .dw XT_STORE
0009a0 f040          .dw XT_DOLITERAL
0009a1 ffff          .dw -1
0009a2 f020          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
0009a3 ff0a          .dw $FF0A
0009a4 6f73
0009a5 7275
0009a6 6563
0009a7 742d
0009a8 6269          .db "source-tib"
0009a9 098f          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
0009aa f000          .dw DO_COLON
                 PFA_SOURCETIB:
0009ab 098d          .dw XT_TIB
0009ac 01c2          .dw XT_NUMBERTIB
0009ad f082          .dw XT_FETCH
0009ae f020          .dw XT_EXIT
                 
                 
                 
                 .include "words/init-user.asm"
                 
                 ; System Value
                 ; address of the default user area content in eeprom
                 VE_EEUSER:
0009af ff07        .dw $ff07
0009b0 6565
0009b1 752d
0009b2 6573
0009b3 0072        .db "ee-user",0
0009b4 09a3        .dw VE_HEAD
                   .set VE_HEAD = VE_EEUSER
                 XT_EEUSER:
0009b5 f04e        .dw PFA_DOVARIABLE
                 PFA_EEUSER:          ; ( -- )
0009b6 0028        .dw EE_INITUSER
                 
                 ; ( e-addr r-addr len -- ) 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
0009b7 ff06        .dw $ff06
0009b8 6565
0009b9 723e
0009ba 6d61        .db "ee>ram"
0009bb 09af        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
0009bc f000        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
0009bd f14b          .dw XT_ZERO
0009be f2b9          .dw XT_DOQDO
0009bf 09ca          .dw PFA_EE2RAM_2
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
0009c0 f0d8          .dw XT_OVER
0009c1 f365          .dw XT_FETCHE
0009c2 f0d8          .dw XT_OVER
0009c3 f08a          .dw XT_STORE
0009c4 01b4          .dw XT_CELLPLUS
0009c5 f0cd          .dw XT_SWAP
0009c6 01b4          .dw XT_CELLPLUS
0009c7 f0cd          .dw XT_SWAP
0009c8 f2ea          .dw XT_DOLOOP
0009c9 09c0          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
0009ca f0e2          .dw XT_DROP
0009cb f0e2          .dw XT_DROP
0009cc f020          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
0009cd ff09        .dw $ff09
0009ce 6e69
0009cf 7469
0009d0 752d
0009d1 6573
0009d2 0072        .db "init-user",0
0009d3 09b7        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
0009d4 f000        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
0009d5 09b5          .dw XT_EEUSER
0009d6 f329          .dw XT_UP_FETCH
0009d7 f040          .dw XT_DOLITERAL
0009d8 001c          .dw SYSUSERSIZE
0009d9 f219          .dw XT_2SLASH
0009da 09bc          .dw XT_EE2RAM
0009db f020          .dw XT_EXIT
                 
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
0009dc ff03          .dw $ff03
0009dd 6d31
0009de 0073          .db "1ms",0
0009df 09cd          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
0009e0 09e1          .dw PFA_1MS
                 PFA_1MS:
0009e1 e3e3
0009e2 e0f7
0009e3 9731
0009e4 f7f1          delay 1000
0009e5 940c f004     jmp_ DO_NEXT
                 
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 VE_2LITERAL:
0009e7 0008          .dw $0008
0009e8 6c32
0009e9 7469
0009ea 7265
0009eb 6c61          .db "2literal"
0009ec 09dc          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
0009ed f000          .dw DO_COLON
                 PFA_2LITERAL:
0009ee f0cd          .dw XT_SWAP
0009ef 0249          .dw XT_COMPILE
0009f0 f040          .dw XT_DOLITERAL
0009f1 0254          .dw XT_COMMA
0009f2 0249          .dw XT_COMPILE
0009f3 f040          .dw XT_DOLITERAL
0009f4 0254          .dw XT_COMMA
                     
0009f5 f020          .dw XT_EXIT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
0009f6 ff03          .dw $ff03
0009f7 7232
0009f8 003e          .db "2r>",0
0009f9 09e7          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
0009fa 09fb          .dw PFA_2R_FROM
                 PFA_2R_FROM:
0009fb 939a
0009fc 938a          savetos
0009fd 918f          pop tosl
0009fe 919f          pop tosh
0009ff 939a
000a00 938a          savetos
000a01 918f          pop tosl
000a02 919f          pop tosh
000a03 940c f004     jmp_ DO_NEXT
                 .include "words/spirw.asm"
                 
                 ; MCU
                 ; SPI exchange of 1 byte
                 VE_SPIRW:
000a05 ff06          .dw $ff06
000a06 2163
000a07 7340
000a08 6970          .db "c!@spi"
000a09 09f6          .dw VE_HEAD
                     .set VE_HEAD  = VE_SPIRW
                 XT_SPIRW:
000a0a 0a0b          .dw PFA_SPIRW
                 PFA_SPIRW:
000a0b d003          rcall do_spirw
000a0c 2799          clr tosh
000a0d 940c f004     jmp_ DO_NEXT
                 
                 do_spirw:
000a0f bd8e          out_ SPDR, tosl
                 do_spirw1:
000a10 b50d          in_ temp0, SPSR
000a11 7f08          cbr temp0,7
000a12 bd0d          out_ SPSR, temp0
000a13 b50d          in_ temp0, SPSR
000a14 ff07          sbrs temp0, 7
000a15 cffa          rjmp do_spirw1   ; wait until complete
000a16 b58e          in_ tosl, SPDR
000a17 9508          ret
                 .include "words/2spirw.asm"
                 
                 ; MCU
                 ; SPI exchange of 2 bytes, high byte first
                 VE_2SPIRW:
000a18 ff05          .dw $ff05
000a19 4021
000a1a 7073
000a1b 0069          .db "!@spi",0
000a1c 0a05          .dw VE_HEAD
                     .set VE_HEAD  = VE_2SPIRW
                 XT_2SPIRW:
000a1d 0a1e          .dw PFA_2SPIRW
                 PFA_2SPIRW:
000a1e 938f          push tosl
000a1f 2f89          mov tosl, tosh
000a20 dfee          call_ do_spirw
000a21 2f98          mov tosh, tosl
000a22 918f          pop tosl
000a23 dfeb          call_ do_spirw
000a24 940c f004     jmp_ DO_NEXT
                 
                 
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
000a26 ff03          .dw $ff03
000a27 3e32
000a28 0072          .db "2>r",0
000a29 0a18          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
000a2a 0a2b          .dw PFA_2TO_R
                 PFA_2TO_R:
000a2b 939f          push tosh
000a2c 938f          push tosl
000a2d 9189
000a2e 9199          loadtos
000a2f 939f          push tosh
000a30 938f          push tosl
000a31 9189
000a32 9199          loadtos
000a33 940c f004     jmp_ DO_NEXT
                 
                 
                 .include "words/bm_clear.asm"
                 
                 ; MCU
                 ; clear bits set in bitmask on byte at addr
                 VE_BM_CLEAR:
000a35 ff08          .dw $ff08
000a36 6d62
000a37 632d
000a38 656c
000a39 7261          .db "bm-clear"
000a3a 0a26          .dw VE_HEAD
                     .set VE_HEAD = VE_BM_CLEAR
                 XT_BM_CLEAR:
000a3b 0a3c          .dw PFA_BM_CLEAR
                 PFA_BM_CLEAR:
000a3c 01fc          movw zl, tosl
000a3d 9189
000a3e 9199          loadtos
000a3f 9580          com tosl
000a40 8100          ld temp0, Z
000a41 2308          and temp0, tosl
000a42 8300          st Z, temp0
000a43 9189
000a44 9199          loadtos
000a45 940c f004     jmp_ DO_NEXT
                 .include "words/bm_set.asm"
                 
                 ; MCU
                 ; set bits from bitmask on byte at addr
                 VE_BM_SET:
000a47 ff06          .dw $ff06
000a48 6d62
000a49 732d
000a4a 7465          .db "bm-set"
000a4b 0a35          .dw VE_HEAD
                     .set VE_HEAD = VE_BM_SET
                 XT_BM_SET:
000a4c 0a4d          .dw PFA_BM_SET
                 PFA_BM_SET:
000a4d 01fc          movw zl, tosl
000a4e 9189
000a4f 9199          loadtos
000a50 8100          ld temp0, Z
000a51 2b08          or temp0, tosl
000a52 8300          st Z, temp0
000a53 9189
000a54 9199          loadtos
000a55 940c f004     jmp_ DO_NEXT
                 .include "words/bm_toggle.asm"
                 
                 ; MCU
                 ; toggle bits set in bitmask on byte at addr
                 VE_BM_TOGGLE:
000a57 ff09          .dw $ff09
000a58 6d62
000a59 742d
000a5a 676f
000a5b 6c67
000a5c 0065          .db "bm-toggle",0
000a5d 0a47          .dw VE_HEAD
                     .set VE_HEAD = VE_BM_TOGGLE
                 XT_BM_TOGGLE:
000a5e 0a5f          .dw PFA_BM_TOGGLE
                 PFA_BM_TOGGLE:
000a5f 01fc          movw zl, tosl
000a60 9189
000a61 9199          loadtos
000a62 8100          ld temp0, Z
000a63 2708          eor temp0, tosl
000a64 8300          st Z, temp0
000a65 9189
000a66 9199          loadtos
000a67 940c f004     jmp_ DO_NEXT
                 .include "words/bracketcompile.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first COMPILEacter of the word on the stack
                 VE_BRACKETCOMPILE:
000a69 0009          .dw $0009
000a6a 635b
000a6b 6d6f
000a6c 6970
000a6d 656c
000a6e 005d          .db "[compile]",0
000a6f 0a57          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCOMPILE
                 XT_BRACKETCOMPILE:
000a70 f000          .dw DO_COLON
                 PFA_BRACKETCOMPILE:
000a71 0249          .dw XT_COMPILE
000a72 0249          .dw XT_COMPILE
000a73 04e2          .dw XT_TICK
000a74 0254          .dw XT_COMMA
000a75 f020          .dw XT_EXIT
                 .include "words/built.asm"
                 
                 ; R( -- )
                 ; prints the date and time the hex file was generated
                 VE_BUILT:
000a76 ff05          .dw $ff05
000a77 7562
000a78 6c69
000a79 0074          .db "built",0
000a7a 0a69          .dw VE_HEAD
                     .set VE_HEAD = VE_BUILT
                 XT_BUILT:
000a7b f000          .dw DO_COLON
                 PFA_BUILT:
000a7c 0443          .dw XT_DOSLITERAL
000a7d 000b          .dw 11
000a7e 7541
000a7f 2067
000a80 3631
000a81 3220
000a82 3130
../../core\words/built.asm(14): warning: .cseg .db misalignment - padding zero byte
000a83 0034          .db __DATE__ ; generated from assembler
000a84 047a          .dw XT_ITYPE
000a85 04bb          .dw XT_SPACE
000a86 0443          .dw XT_DOSLITERAL
000a87 0008          .dw 8
000a88 3831
000a89 333a
000a8a 3a32
000a8b 3734          .db __TIME__ ; generated from assembler
000a8c 047a          .dw XT_ITYPE
000a8d f020          .dw XT_EXIT
                 .include "words/count.asm"
                 
                 ; String
                 ; convert addr of counted string to address of the first characater and length of the string
                 VE_COUNT:
000a8e ff05          .dw $ff05
000a8f 6f63
000a90 6e75
000a91 0074          .db "count",0
000a92 0a76          .dw VE_HEAD
                     .set VE_HEAD = VE_COUNT
                 XT_COUNT:
000a93 f000          .dw DO_COLON
                 PFA_COUNT:
000a94 f0ba          .dw XT_DUP
000a95 f244          .dw XT_1PLUS
000a96 f0cd          .dw XT_SWAP
000a97 f0a1          .dw XT_CFETCH
000a98 f020          .dw XT_EXIT
                 .include "words/d-equal.asm"
                 
                 ; Compare
                 ; compares two double cell values
                 VE_DEQUAL:
000a99 ff02          .dw $ff02
000a9a 3d64          .db "d="
000a9b 0a8e          .dw VE_HEAD
                     .set VE_HEAD = VE_DEQUAL
                 XT_DEQUAL:
000a9c 0a9d          .dw PFA_DEQUAL
                 PFA_DEQUAL:
000a9d 9129          ld temp2, Y+
000a9e 9139          ld temp3, Y+
                 
000a9f 90e9          ld temp4, Y+
000aa0 90f9          ld temp5, Y+
000aa1 9149          ld temp6, Y+
000aa2 9159          ld temp7, Y+
                 
000aa3 158e          cp tosl, temp4
000aa4 059f          cpc tosh, temp5
000aa5 0724          cpc temp2, temp6
000aa6 0735          cpc temp3, temp7
                 
000aa7 f011          breq PFA_DEQUALTRUE
000aa8 940c f14e     jmp_ PFA_ZERO1
                 PFA_DEQUALTRUE:
000aaa 940c f157     jmp_ PFA_TRUE1
                 
                 .include "words/do2literal.asm"
                 
                 ; System
                 ; runtime of 2literal
                 ;VE_DO2LITERAL:
                 ;    .dw $ff0a
                 ;    .db "(2literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DO2LITERAL
                 XT_DO2LITERAL:
000aac 0aad          .dw PFA_DO2LITERAL
                 PFA_DO2LITERAL:
000aad 939a
000aae 938a          savetos
000aaf 01fd          movw zl, xl
000ab0 2755
000ab1 0fee
000ab2 1fff
000ab3 1f55
000ab4 bf5b
000ab5 9107
000ab6 9117          readflashcell temp0,temp1
000ab7 01fd          movw zl, xl
000ab8 9631          adiw zl, 1
000ab9 2755
000aba 0fee
000abb 1fff
000abc 1f55
000abd bf5b
000abe 9187
000abf 9197          readflashcell tosl,tosh
000ac0 939a
000ac1 938a          savetos
000ac2 01c8          movw tosl, temp0
000ac3 9612          adiw xl, 2
000ac4 940c f004     jmp_ DO_NEXT
                 
                 
                 
                 
                 
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
000ac6 ff04          .dw $ff04
000ac7 6966
000ac8 6c6c          .db "fill"
000ac9 0a99          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
000aca f000          .dw DO_COLON
                 PFA_FILL:
000acb f0ea          .dw XT_ROT
000acc f0ea          .dw XT_ROT
000acd f14b          .dw XT_ZERO
000ace f2b9          .dw XT_DOQDO
000acf 0ad6          .dw PFA_FILL2
                 PFA_FILL1:
000ad0 f0d8          .dw XT_OVER
000ad1 f0d8          .dw XT_OVER
000ad2 f096          .dw XT_CSTORE  ; ( -- c c-addr)
000ad3 f244          .dw XT_1PLUS
000ad4 f2ea          .dw XT_DOLOOP
000ad5 0ad0          .dw PFA_FILL1
                 PFA_FILL2:
000ad6 f0e2          .dw XT_DROP
000ad7 f0e2          .dw XT_DROP
000ad8 f020          .dw XT_EXIT
                 .include "words/find.asm"
                 
                 ; Tools
                 ; search wordlists for entry taken as counted string from addr
                 VE_FIND:
000ad9 ff04          .dw $ff04
000ada 6966
000adb 646e          .db "find"
000adc 0ac6          .dw VE_HEAD
                     .set VE_HEAD = VE_FIND
                 XT_FIND:
000add f000          .dw DO_COLON
                 PFA_FIND:
000ade f0ba          .dw XT_DUP
000adf 0a93          .dw XT_COUNT
000ae0 06c0          .dw XT_FINDNAME ; ( -- addr [xt] flag )
000ae1 f0ba          .dw XT_DUP
000ae2 f039          .dw XT_DOCONDBRANCH
000ae3 0ae6          .dw PFA_FIND1
000ae4 f0ea             .dw XT_ROT
000ae5 f0e2             .dw XT_DROP
                 PFA_FIND1:
000ae6 f020          .dw XT_EXIT
                 .include "words/get-recognizer.asm"
                 
                 ; Interpreter
                 ; Get the current recognizer list
                 VE_GET_RECOGNIZER:
000ae7 ff0e          .dw $ff0e
000ae8 6567
000ae9 2d74
000aea 6572
000aeb 6f63
000aec 6e67
000aed 7a69
000aee 7265          .db "get-recognizer"
000aef 0ad9          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_RECOGNIZER
                 XT_GET_RECOGNIZER:
000af0 f000          .dw DO_COLON
                 PFA_GET_RECOGNIZER:
000af1 f040          .dw XT_DOLITERAL
000af2 0044          .dw EE_RECOGNIZERLISTLEN
000af3 0f87          .dw XT_FETCH_EE_ARRAY
000af4 f020          .dw XT_EXIT
                 .include "words/int-num.asm"
                 
                 ; Interrupt
                 ; number of interrupt vectors (0 based)
                 VE_NUMINT:
000af5 ff04          .dw $ff04
000af6 6923
000af7 746e          .db "#int"
000af8 0ae7          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMINT
                 XT_NUMINT:
000af9 f04e          .dw PFA_DOVARIABLE
                 PFA_NUMINT:
000afa 0039          .dw INTVECTORS
                 .include "words/ms.asm"
                 
                 ; Time
                 ; busy waits the specified amount of milliseconds
                 VE_MS:
000afb ff02          .dw $ff02
000afc 736d          .db "ms"
000afd 0af5          .dw VE_HEAD
                     .set VE_HEAD = VE_MS
                 XT_MS:
000afe f000          .dw DO_COLON
                 PFA_MS:
000aff f14b          .dw XT_ZERO
000b00 f2b9          .dw XT_DOQDO
000b01 0b05          .dw PFA_MS2
                 PFA_MS1:
000b02 09e0          .dw XT_1MS
000b03 f2ea          .dw XT_DOLOOP
000b04 0b02          .dw PFA_MS1
                 PFA_MS2:
000b05 f020          .dw XT_EXIT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_R_FROM:
000b06 ff03          .dw $ff03
000b07 726e
000b08 003e          .db "nr>",0
000b09 0afb          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
000b0a 0b0b          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
000b0b 939a
000b0c 938a          savetos
000b0d 91ff          pop zh
000b0e 91ef          pop zl
000b0f 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
000b10 918f          pop tosl
000b11 919f          pop tosh
000b12 939a
000b13 938a          savetos
000b14 950a          dec temp0
000b15 f7d1          brne PFA_N_R_FROM1
000b16 01cf          movw tosl, zl
000b17 940c f004     jmp_ DO_NEXT
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
000b19 ff03          .dw $ff03
000b1a 3e6e
000b1b 0072          .db "n>r",0
000b1c 0b06          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
000b1d 0b1e          .dw PFA_N_TO_R
                 PFA_N_TO_R:
000b1e 01fc          movw zl, tosl
000b1f 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
000b20 9189
000b21 9199          loadtos
000b22 939f          push tosh
000b23 938f          push tosl
000b24 950a          dec temp0
000b25 f7d1          brne PFA_N_TO_R1
000b26 93ef          push zl
000b27 93ff          push zh
000b28 9189
000b29 9199          loadtos
000b2a 940c f004     jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
000b2c ff03          .dw $ff03
000b2d 696e
000b2e 0070          .db "nip",0
000b2f 0b19          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
000b30 0b31          .dw PFA_NIP
                 PFA_NIP:
000b31 9622          adiw yl, 2
000b32 940c f004     jmp_ DO_NEXT
                 .include "words/no-jtag.asm"
                 
                 ; MCU
                 ; disable jtag at runtime
                 VE_NOJTAG:
000b34 ff05          .dw $FF05
000b35 6a2d
000b36 6174
000b37 0067          .db "-jtag",0
000b38 0b2c          .dw VE_HEAD
                     .set VE_HEAD = VE_NOJTAG
                 XT_NOJTAG:
000b39 0b3a          .dw PFA_NOJTAG
                 PFA_NOJTAG:
000b3a 94f8          cli
                     .ifdef MCUCSR
                     .else
000b3b b705          in_ temp0, MCUCR
                     .endif
                 
000b3c 6800          ori temp0, ( 1<<JTD)
                 
                     .ifdef MCUCSR
                     .else
000b3d bf05          out_ MCUCR, temp0
000b3e bf05          out_ MCUCR, temp0     ; needs to be done twice within 4 cycles
                     .endif
000b3f 9478          sei
000b40 940c f004     jmp_ DO_NEXT
                 .include "words/notequalzero.asm"
                 
                 ; Compare
                 ; true if n is not zero
                 VE_NOTEQUALZERO:
000b42 ff03          .dw $ff03
000b43 3c30
000b44 003e          .db "0<>",0
000b45 0b34          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUALZERO
                 XT_NOTEQUALZERO:
000b46 f000          .dw DO_COLON
                 PFA_NOTEQUALZERO:
000b47 f129          .dw XT_EQUALZERO
000b48 f129          .dw XT_EQUALZERO
000b49 f020          .dw XT_EXIT
                 .include "words/pick.asm"
                 
                 ; Stack
                 ; access the stack as an array and fetch the u-th element as new TOS
                 VE_PICK:
000b4a ff04          .dw $ff04
000b4b 6970
000b4c 6b63          .db "pick"
000b4d 0b42          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
000b4e 0b4f          .dw PFA_PICK
                 PFA_PICK:
000b4f 01fe          movw zl, yl
000b50 0f88          lsl tosl
000b51 1f99          rol tosh
000b52 0fe8          add  zl,tosl
000b53 1ff9          adc  zh,tosh
000b54 8180          ld   tosl, Z
000b55 8191          ldd  tosh, Z+1
000b56 940c f004     jmp_ DO_NEXT
                 .include "words/place.asm"
                 
                 ; String
                 ; copy string as counted string
                 VE_PLACE:
000b58 ff05          .dw $ff05
000b59 6c70
000b5a 6361
000b5b 0065          .db "place",0
000b5c 0b4a          .dw VE_HEAD
                     .set VE_HEAD = VE_PLACE
                 XT_PLACE:
000b5d f000          .dw DO_COLON
                 PFA_PLACE:
000b5e f0d8          .dw XT_OVER        ; ( -- addr1 len1 addr2 len1)
000b5f f0d8          .dw XT_OVER        ; ( -- addr1 len1 addr2 len1 addr2)
000b60 f096          .dw XT_CSTORE      ; ( -- addr1 len1 addr2)
000b61 f244          .dw XT_1PLUS       ; ( -- addr1 len1 addr2')
000b62 f0cd          .dw XT_SWAP        ; ( -- addr1 addr2' len1)
000b63 f306          .dw XT_CMOVE_G     ; ( --- )
000b64 f020          .dw XT_EXIT
                 .include "words/popcnt.asm"
                 
                 ; Arithmetics
                 ; count the Number of 1 bits (population count)
                 VE_POPCNT:
000b65 ff06          .dw $ff06
000b66 6f70
000b67 6370
000b68 746e          .db "popcnt"
000b69 0b58          .dw VE_HEAD
                     .set VE_HEAD = VE_POPCNT
                 XT_POPCNT:
000b6a 0b6b          .dw PFA_POPCNT
                 PFA_POPCNT:
000b6b 01fc          movw zl, tosl
000b6c 2788          clr tosl
000b6d d005          rcall PFA_POPCNT1
000b6e 2fef          mov zl, zh
000b6f d003          rcall PFA_POPCNT1
000b70 2799          clr tosh
000b71 940c f004     jmp_ DO_NEXT
                 
                 PFA_POPCNT1:
000b73 e098          ldi tosh, 8
                 PFA_POPCNT2:
000b74 95e7          ror zl
                     ;breq PFA_POPCNT3
000b75 1d83          adc tosl, zeroh
000b76 959a          dec tosh
000b77 f7e1          brne PFA_POPCNT2
                 POPCNT3:
                 .include "words/reg-a.asm"
000b78 9508      
                 ; Extended VM
                 ; Read memory pointed to by register A (Extended VM)
                 VE_AFETCH:
000b79 ff02          .dw $ff02
000b7a 4061          .db "a@"
000b7b 0b65          .dw VE_HEAD
                     .set VE_HEAD = VE_AFETCH
                 XT_AFETCH:
000b7c 0b7d          .dw PFA_AFETCH
                 PFA_AFETCH:
000b7d 939a
000b7e 938a          savetos
000b7f 01f3          movw zl, al
000b80 9181          ld tosl, Z+
000b81 9191          ld tosh, Z+
000b82 940c f004     jmp_ DO_NEXT
                 
                 ; ( n1 -- n2 )
                 ; Extended VM
                 ; Read memory pointed to by register A plus offset (Extended VM)
                 VE_NAFETCH:
000b84 ff03          .dw $ff03
000b85 616e
000b86 0040          .db "na@",0
000b87 0b79          .dw VE_HEAD
                     .set VE_HEAD = VE_NAFETCH
                 XT_NAFETCH:
000b88 0b89          .dw PFA_NAFETCH
                 PFA_NAFETCH:
000b89 01f3          movw zl, al
000b8a 0fe8          add zl, tosl
000b8b 1ff9          adc zh, tosh
000b8c 9181          ld tosl, Z+
000b8d 9191          ld tosh, Z+
000b8e 940c f004     jmp_ DO_NEXT
                 
                 ; ( -- n ) 
                 ; Extended VM
                 ; Read memory pointed to by register A, increment A by 1 cell (Extended VM)
                 VE_AFETCHPLUS:
000b90 ff03          .dw $ff03
000b91 4061
000b92 002b          .db "a@+",0
000b93 0b84          .dw VE_HEAD
                     .set VE_HEAD = VE_AFETCHPLUS
                 XT_AFETCHPLUS:
000b94 0b95          .dw PFA_AFETCHPLUS
                 PFA_AFETCHPLUS:
000b95 939a
000b96 938a          savetos
000b97 01f3          movw zl, al
000b98 9181          ld tosl, Z+
000b99 9191          ld tosh, Z+
000b9a 013f          movw al, zl
000b9b 940c f004     jmp_ DO_NEXT
                 
                 ; ( -- n )
                 ; Extended VM
                 ; Read memory pointed to by register A, decrement A by 1 cell (Extended VM)
                 VE_AFETCHMINUS:
000b9d ff03          .dw $ff03
000b9e 4061
000b9f 002d          .db "a@-",0
000ba0 0b90          .dw VE_HEAD
                     .set VE_HEAD = VE_AFETCHMINUS
                 XT_AFETCHMINUS:
000ba1 0ba2          .dw PFA_AFETCHMINUS
                 PFA_AFETCHMINUS:
000ba2 939a
000ba3 938a          savetos
000ba4 01f3          movw zl, al
000ba5 9192          ld tosh, -Z  ; TODO: check byte order!! 
000ba6 9182          ld tosl, -Z
000ba7 013f          movw al, zl
000ba8 940c f004     jmp_ DO_NEXT
                 
                 ; ( n -- )
                 ; Extended VM
                 ; Write memory pointed to by register A (Extended VM)
                 VE_ASTORE:
000baa ff02          .dw $ff02
000bab 2161          .db "a!"
000bac 0b9d          .dw VE_HEAD
                     .set VE_HEAD = VE_ASTORE
                 XT_ASTORE:
000bad 0bae          .dw PFA_ASTORE
                 PFA_ASTORE:
000bae 01f3          movw zl, al
000baf 9381          st Z+, tosl
000bb0 9391          st Z+, tosh
000bb1 9189
000bb2 9199          loadtos
000bb3 940c f004     jmp_ DO_NEXT
                 
                 ; ( n offs -- )
                 ; Extended VM
                 ; Write memory pointed to by register A plus offset (Extended VM)
                 VE_NASTORE:
000bb5 ff03          .dw $ff03
000bb6 616e
000bb7 0021          .db "na!",0
000bb8 0baa          .dw VE_HEAD
                     .set VE_HEAD = VE_NASTORE
                 XT_NASTORE:
000bb9 0bba          .dw PFA_NASTORE
                 PFA_NASTORE:
000bba 01f3          movw zl, al
000bbb 0fe8          add zl, tosl
000bbc 1ff9          adc zh, tosh
000bbd 9189
000bbe 9199          loadtos
000bbf 9381          st Z+, tosl
000bc0 9391          st Z+, tosh
000bc1 9189
000bc2 9199          loadtos
000bc3 940c f004     jmp_ DO_NEXT
                 
                 ; ( -- n2 )
                 ; Extended VM
                 ; Write memory pointed to by register A, increment A by 1 cell (Extended VM)
                 VE_ASTOREPLUS:
000bc5 ff03          .dw $ff03
000bc6 2161
000bc7 002b          .db "a!+",0
000bc8 0bb5          .dw VE_HEAD
                     .set VE_HEAD = VE_ASTOREPLUS
                 XT_ASTOREPLUS:
000bc9 0bca          .dw PFA_ASTOREPLUS
                 PFA_ASTOREPLUS:
000bca 01f3          movw zl, al
000bcb 9381          st Z+, tosl
000bcc 9391          st Z+, tosh
000bcd 9189
000bce 9199          loadtos
000bcf 013f          movw al, zl
000bd0 940c f004     jmp_ DO_NEXT
                 
                 ; ( -- n2 )
                 ; Extended VM
                 ; Write memory pointed to by register A, decrement A by 1 cell (Extended VM)
                 VE_ASTOREMINUS:
000bd2 ff03          .dw $ff03
000bd3 2161
000bd4 002d          .db "a!-",0
000bd5 0bc5          .dw VE_HEAD
                     .set VE_HEAD = VE_ASTOREMINUS
                 XT_ASTOREMINUS:
000bd6 0bd7          .dw PFA_ASTOREMINUS
                 PFA_ASTOREMINUS:
000bd7 01f3          movw zl, al
000bd8 9392          st -Z, tosh
000bd9 9382          st -Z, tosl
000bda 9189
000bdb 9199          loadtos
000bdc 013f          movw al, zl
000bdd 940c f004     jmp_ DO_NEXT
                 
                 
                 
                 ; ( n -- )
                 ; Extended VM
                 ; Write to A register (Extended VM)
                 VE_TO_A:
000bdf ff02          .dw $ff02
000be0 613e          .db ">a"
000be1 0bd2          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_A
                 XT_TO_A:
000be2 0be3          .dw PFA_TO_A
                 PFA_TO_A:
000be3 013c          movw al, tosl
000be4 9189
000be5 9199          loadtos
000be6 940c f004     jmp_ DO_NEXT
                 
                 ; ( n1 -- n2 ) 
                 ; Extended VM
                 ; read the A register (Extended VM)
                 VE_A_FROM:
000be8 ff02          .dw $ff02
000be9 3e61          .db "a>"
000bea 0bdf          .dw VE_HEAD
                     .set VE_HEAD = VE_A_FROM
                 XT_A_FROM:
000beb 0bec          .dw PFA_A_FROM
                 PFA_A_FROM:
000bec 939a
000bed 938a          savetos
000bee 01c3          movw tosl, al
000bef 940c f004     jmp_ DO_NEXT
                 
                 ; for more information read
                 ; http://www.complang.tuwien.ac.at/anton/euroforth/ef08/papers/pelc.pdf
                 ;  adapted index based access from X/Y registers
                 ;    note: offset is byte address, not cell!
                 .include "words/reg-b.asm"
                 
                 ; Extended VM
                 ; Read memory pointed to by register B (Extended VM)
                 VE_BFETCH:
000bf1 ff02          .dw $ff02
000bf2 4062          .db "b@"
000bf3 0be8          .dw VE_HEAD
                     .set VE_HEAD = VE_BFETCH
                 XT_BFETCH:
000bf4 0bf5          .dw PFA_BFETCH
                 PFA_BFETCH:
000bf5 939a
000bf6 938a          savetos
000bf7 01f4          movw zl, bl
000bf8 9181          ld tosl, Z+
000bf9 9191          ld tosh, Z+
000bfa 940c f004     jmp_ DO_NEXT
                 
                 ; ( n1 -- n2 )
                 ; Extended VM
                 ; Read memory pointed to by register B plus offset (Extended VM)
                 VE_NBFETCH:
000bfc ff03          .dw $ff03
000bfd 626e
000bfe 0040          .db "nb@",0
000bff 0bf1          .dw VE_HEAD
                     .set VE_HEAD = VE_NBFETCH
                 XT_NBFETCH:
000c00 0c01          .dw PFA_NBFETCH
                 PFA_NBFETCH:
000c01 01f4          movw zl, bl
000c02 0fe8          add zl, tosl
000c03 1ff9          adc zh, tosh
000c04 9181          ld tosl, Z+
000c05 9191          ld tosh, Z+
000c06 940c f004     jmp_ DO_NEXT
                 
                 ; ( -- n )
                 ; Extended VM
                 ; Read memory pointed to by register B, increment B by 1 cell (Extended VM)
                 VE_BFETCHPLUS:
000c08 ff03          .dw $ff03
000c09 4062
000c0a 002b          .db "b@+",0
000c0b 0bfc          .dw VE_HEAD
                     .set VE_HEAD = VE_BFETCHPLUS
                 XT_BFETCHPLUS:
000c0c 0c0d          .dw PFA_BFETCHPLUS
                 PFA_BFETCHPLUS:
000c0d 939a
000c0e 938a          savetos
000c0f 01f4          movw zl, bl
000c10 9181          ld tosl, Z+
000c11 9191          ld tosh, Z+
000c12 014f          movw bl, zl
000c13 940c f004     jmp_ DO_NEXT
                 
                 ; ( -- n )
                 ; Extended VM
                 ; Read memory pointed to by register B, decrement B by 1 cell (Extended VM)
                 VE_BFETCHMINUS:
000c15 ff03          .dw $ff03
000c16 4062
000c17 002d          .db "b@-",0
000c18 0c08          .dw VE_HEAD
                     .set VE_HEAD = VE_BFETCHMINUS
                 XT_BFETCHMINUS:
000c19 0c1a          .dw PFA_BFETCHMINUS
                 PFA_BFETCHMINUS:
000c1a 939a
000c1b 938a          savetos
000c1c 01f4          movw zl, bl
000c1d 9192          ld tosh, -Z
000c1e 9182          ld tosl, -Z
000c1f 014f          movw bl, zl
000c20 940c f004     jmp_ DO_NEXT
                 
                 ; ( n -- )
                 ; Extended VM
                 ; Write memory pointed to by register B (Extended VM)
                 VE_BSTORE:
000c22 ff02          .dw $ff02
000c23 2162          .db "b!"
000c24 0c15          .dw VE_HEAD
                     .set VE_HEAD = VE_BSTORE
                 XT_BSTORE:
000c25 0c26          .dw PFA_BSTORE
                 PFA_BSTORE:
000c26 01f4          movw zl, bl
000c27 9381          st Z+, tosl
000c28 9391          st Z+, tosh
000c29 9189
000c2a 9199          loadtos
000c2b 940c f004     jmp_ DO_NEXT
                 
                 ; ( n offs -- )
                 ; Extended VM
                 ; Write memory pointed to by register B plus offset (Extended VM)
                 VE_NBSTORE:
000c2d ff03          .dw $ff03
000c2e 626e
000c2f 0021          .db "nb!",0
000c30 0c22          .dw VE_HEAD
                     .set VE_HEAD = VE_NBSTORE
                 XT_NBSTORE:
000c31 0c32          .dw PFA_NBSTORE
                 PFA_NBSTORE:
000c32 01f4          movw zl, bl
000c33 0fe8          add zl, tosl
000c34 1ff9          adc zh, tosh
000c35 9189
000c36 9199          loadtos
000c37 9381          st Z+, tosl
000c38 9391          st Z+, tosh
000c39 9189
000c3a 9199          loadtos
000c3b 940c f004     jmp_ DO_NEXT
                 
                 ; ( -- n2 )
                 ; Extended VM
                 ; Write memory pointed to by register B, increment B by 1 cell (Extended VM)
                 VE_BSTOREPLUS:
000c3d ff03          .dw $ff03
000c3e 2162
000c3f 002b          .db  "b!+",0
000c40 0c2d          .dw VE_HEAD
                     .set VE_HEAD = VE_BSTOREPLUS
                 XT_BSTOREPLUS:
000c41 0c42          .dw PFA_BSTOREPLUS
                 PFA_BSTOREPLUS:
000c42 01f4          movw zl, bl
000c43 9381          st Z+, tosl
000c44 9391          st Z+, tosh
000c45 9189
000c46 9199          loadtos
000c47 014f          movw bl, zl
000c48 940c f004     jmp_ DO_NEXT
                 
                 ; ( -- n2 )
                 ; Extended VM
                 ; Write memory pointed to by register B, decrement B by 1 cell (Extended VM)
                 VE_BSTOREMINUS:
000c4a ff03          .dw $ff03
000c4b 2162
000c4c 002d          .db "b!-",0
000c4d 0c3d          .dw VE_HEAD
                     .set VE_HEAD = VE_BSTOREMINUS
                 XT_BSTOREMINUS:
000c4e 0c4f          .dw PFA_BSTOREMINUS
                 PFA_BSTOREMINUS:
000c4f 01f4          movw zl, bl
000c50 9392          st -Z, tosh
000c51 9382          st -Z, tosl
000c52 9189
000c53 9199          loadtos
000c54 014f          movw bl, zl
000c55 940c f004     jmp_ DO_NEXT
                 
                 
                 
                 ; ( n -- )
                 ; Extended VM
                 ; Write to B register (Extended VM)
                 VE_TO_B:
000c57 ff02          .dw $ff02
000c58 623e          .db ">b"
000c59 0c4a          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_B
                 XT_TO_B:
000c5a 0c5b          .dw PFA_TO_B
                 PFA_TO_B:
000c5b 014c          movw bl, tosl
000c5c 9189
000c5d 9199          loadtos
000c5e 940c f004     jmp_ DO_NEXT
                 
                 ; ( n1 -- n2 )
                 ; Extended VM
                 ; read the B register (Extended VM)
                 VE_B_FROM:
000c60 ff02          .dw $ff02
000c61 3e62          .db "b>"
000c62 0c57          .dw VE_HEAD
                     .set VE_HEAD = VE_B_FROM
                 XT_B_FROM:
000c63 0c64          .dw PFA_B_FROM
                 PFA_B_FROM:
000c64 939a
000c65 938a          savetos
000c66 01c4          movw tosl, bl
000c67 940c f004     jmp_ DO_NEXT
                 
                 ; for more information read
                 ; http://www.complang.tuwien.ac.at/anton/euroforth/ef08/papers/pelc.pdf
                 ;  adapted index based access from X/Y registers
                 ;    note: offset is byte address, not cell!
                 .include "words/set-recognizer.asm"
                 
                 ; Interpreter
                 ; replace the recognizer list
                 VE_SET_RECOGNIZER:
000c69 ff0e          .dw $ff0e
000c6a 6573
000c6b 2d74
000c6c 6572
000c6d 6f63
000c6e 6e67
000c6f 7a69
000c70 7265          .db "set-recognizer"
000c71 0c60          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_RECOGNIZER
                 XT_SET_RECOGNIZER:
000c72 f000          .dw DO_COLON
                 PFA_SET_RECOGNIZER:
000c73 f040          .dw XT_DOLITERAL
000c74 0044          .dw EE_RECOGNIZERLISTLEN
000c75 0fa1          .dw XT_STORE_EE_ARRAY
000c76 f020          .dw XT_EXIT
                 
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
000c77 ff03          .dw $ff03
000c78 3264
000c79 002a          .db "d2*",0
000c7a 0c69          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
000c7b 0c7c          .dw PFA_D2STAR
                 PFA_D2STAR:
000c7c 9109          ld temp0, Y+
000c7d 9119          ld temp1, Y+
000c7e 0f00          lsl temp0
000c7f 1f11          rol temp1
000c80 1f88          rol tosl
000c81 1f99          rol tosh
000c82 931a          st -Y, temp1
000c83 930a          st -Y, temp0
000c84 940c f004     jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
000c86 ff02          .dw $ff02
000c87 2b64          .db "d+"
000c88 0c77          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
000c89 0c8a          .dw PFA_DPLUS
                 PFA_DPLUS:
000c8a 9129          ld temp2, Y+
000c8b 9139          ld temp3, Y+
                 
000c8c 90e9          ld temp4, Y+
000c8d 90f9          ld temp5, Y+
000c8e 9149          ld temp6, Y+
000c8f 9159          ld temp7, Y+
                 
000c90 0f24          add temp2, temp6
000c91 1f35          adc temp3, temp7
000c92 1d8e          adc tosl, temp4
000c93 1d9f          adc tosh, temp5
                     
000c94 933a          st -Y, temp3
000c95 932a          st -Y, temp2
000c96 940c f004     jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
000c98 ff02          .dw $ff02
000c99 2d64          .db "d-"
000c9a 0c86          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
000c9b 0c9c          .dw PFA_DMINUS
                 PFA_DMINUS:
000c9c 9129          ld temp2, Y+
000c9d 9139          ld temp3, Y+
                 
000c9e 90e9          ld temp4, Y+
000c9f 90f9          ld temp5, Y+
000ca0 9149          ld temp6, Y+
000ca1 9159          ld temp7, Y+
                 
000ca2 1b42          sub temp6, temp2
000ca3 0b53          sbc temp7, temp3
000ca4 0ae8          sbc temp4, tosl
000ca5 0af9          sbc temp5, tosh
                 
000ca6 935a          st -Y, temp7
000ca7 934a          st -Y, temp6
000ca8 01c7          movw tosl, temp4
000ca9 940c f004     jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
000cab ff07          .dw $ff07
000cac 6964
000cad 766e
000cae 7265
000caf 0074          .db "dinvert",0
000cb0 0c98          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
000cb1 0cb2          .dw PFA_DINVERT
                 PFA_DINVERT:
000cb2 9109          ld temp0, Y+
000cb3 9119          ld temp1, Y+
000cb4 9580          com tosl
000cb5 9590          com tosh
000cb6 9500          com temp0
000cb7 9510          com temp1
000cb8 931a          st -Y, temp1
000cb9 930a          st -Y, temp0
000cba 940c f004     jmp_ DO_NEXT
                 .include "words/udot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 VE_UDOT:
000cbc ff02          .dw $ff02
000cbd 2e75          .db "u."
000cbe 0cab          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
000cbf f000          .dw DO_COLON
                 PFA_UDOT:
000cc0 f14b          .dw XT_ZERO
000cc1 03e1          .dw XT_UDDOT
000cc2 f020          .dw XT_EXIT
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 VE_DOTS:
000cc3 ff02          .dw $ff02
000cc4 732e          .db ".s"
000cc5 0cbc          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
000cc6 f000          .dw DO_COLON
                 PFA_DOTS:
000cc7 075d          .dw XT_SP0
000cc8 f296          .dw XT_SP_FETCH
000cc9 01b4          .dw XT_CELLPLUS
000cca f2b9          .dw XT_DOQDO
000ccb 0cd3          .dw PFA_DOTS2
                 PFA_DOTS1:
000ccc f2cf          .dw XT_I
000ccd f082          .dw XT_FETCH 
000cce 0cbf          .dw XT_UDOT
000ccf f040          .dw XT_DOLITERAL
000cd0 0002          .dw 2
000cd1 f2d0          .dw XT_DOPLUSLOOP
000cd2 0ccc          .dw PFA_DOTS1
                 PFA_DOTS2:
000cd3 f020          .dw XT_EXIT
                 .include "words/udotr.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 VE_UDOTR:
000cd4 ff03          .dw $ff03
000cd5 2e75
000cd6 0072          .db "u.r",0
000cd7 0cc3          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
000cd8 f000          .dw DO_COLON
                 PFA_UDOTR:
000cd9 f14b          .dw XT_ZERO
000cda f0cd          .dw XT_SWAP
000cdb 03ea          .dw XT_UDDOTR
000cdc f020          .dw XT_EXIT
                 .include "words/uzerodotr.asm"
                 
                 ; Numeric IO
                 ; Print n digits, fill in preceeding zeros if needed
                 VE_UZERODOTR:
000cdd ff04          .dw $ff04
000cde 3075
000cdf 722e          .db "u0.r"
000ce0 0cd4          .dw VE_HEAD
                     .set VE_HEAD = VE_UZERODOTR
                 XT_UZERODOTR:
000ce1 f000          .dw DO_COLON
                 PFA_UZERODOTR:
000ce2 f101          .dw XT_TO_R
000ce3 f14b          .dw XT_ZERO
000ce4 0371          .dw XT_L_SHARP
000ce5 f0f8          .dw XT_R_FROM
000ce6 f14b          .dw XT_ZERO
000ce7 f2b9          .dw XT_DOQDO
000ce8 0cec          .dw PFA_UZERODOTR2
                 PFA_UZERODOTR1:
000ce9 0379          .dw XT_SHARP
000cea f2ea          .dw XT_DOLOOP
000ceb 0ce9          .dw PFA_UZERODOTR1
                 PFA_UZERODOTR2:
000cec 039b          .dw XT_SHARP_G
000ced 04d3          .dw XT_TYPE
000cee f020          .dw XT_EXIT
                 .include "words/dotstring.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 VE_DOTSTRING:
000cef 0002          .dw $0002
000cf0 222e          .db ".",$22
000cf1 0cdd          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
000cf2 f000          .dw DO_COLON
                 PFA_DOTSTRING:
000cf3 0cfa          .dw XT_SQUOTE
000cf4 0249          .dw XT_COMPILE
000cf5 047a          .dw XT_ITYPE
000cf6 f020          .dw XT_EXIT
                 
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SQUOTE:
000cf7 0002        .dw $0002
000cf8 2273        .db "s",$22
000cf9 0cef        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
000cfa f000          .dw DO_COLON
                 PFA_SQUOTE:
000cfb f040          .dw XT_DOLITERAL
000cfc 0022          .dw $22
000cfd 0653          .dw XT_PARSE       ; ( -- addr n)
000cfe 019f          .dw XT_STATE
000cff f082          .dw XT_FETCH
000d00 f039          .dw XT_DOCONDBRANCH
000d01 0d05          .dw PFA_SQUOTE1
000d02 0249            .dw XT_COMPILE
000d03 0443            .dw XT_DOSLITERAL    ; ( -- addr n)
000d04 0456            .dw XT_SCOMMA
                 PFA_SQUOTE1:
000d05 f020          .dw XT_EXIT
                 .include "words/wdr.asm"
                 
                 ; MCU
                 ; calls the MCU watch dog reset instruction
                 VE_WDR:
000d06 ff03          .dw $ff03
000d07 6477
000d08 0072          .db "wdr",0
000d09 0cf7          .dw VE_HEAD
                     .set VE_HEAD = VE_WDR
                 XT_WDR:
000d0a 0d0b          .dw PFA_WDR
                 PFA_WDR:
000d0b 95a8          wdr
000d0c 940c f004     jmp_ DO_NEXT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
000d0e ff05          .dw $ff05
000d0f 6f77
000d10 6472
000d11 0073          .db "words",0
000d12 0d06          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
000d13 f000          .dw DO_COLON
                 PFA_WORDS:
000d14 f040          .dw XT_DOLITERAL
000d15 0018          .dw EE_ORDERLIST
000d16 f365          .dw XT_FETCHE
000d17 100a          .dw XT_SHOWWORDLIST
000d18 f020          .dw XT_EXIT
                 .include "words/word.asm"
                 
                 ; Tools
                 ; skip leading delimiter character and parse SOURCE until the next delimiter. copy the word to HERE
                 VE_WORD:
000d19 ff04          .dw $ff04
000d1a 6f77
000d1b 6472          .db "word"
000d1c 0d0e          .dw VE_HEAD
                     .set VE_HEAD = VE_WORD
                 XT_WORD:
000d1d f000          .dw DO_COLON
                 PFA_WORD:
000d1e 06a6          .dw XT_SKIPSCANCHAR ; factor for both parse/word
                     ; move to HERE
000d1f 0202          .dw XT_HERE
000d20 0b5d          .dw XT_PLACE
                     ; leave result
000d21 0202          .dw XT_HERE
000d22 f020          .dw XT_EXIT
                 .include "words/edefer.asm"
                 
                 ; Compiler
                 ; creates a defer vector which is kept in eeprom.
                 VE_EDEFER:
000d23 ff06          .dw $ff06
000d24 6445
000d25 6665
000d26 7265          .db "Edefer"
000d27 0d19          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFER
                 XT_EDEFER:
000d28 f000          .dw DO_COLON
                 PFA_EDEFER:
000d29 0217          .dw XT_DOCREATE
000d2a 0e37          .dw XT_REVEAL
000d2b 0249          .dw XT_COMPILE
000d2c 089d          .dw PFA_DODEFER
                 
000d2d 01fa          .dw XT_EDP
000d2e f0ba          .dw XT_DUP
000d2f 0254          .dw XT_COMMA
000d30 0249          .dw XT_COMPILE
000d31 0861          .dw XT_EDEFERFETCH
000d32 0249          .dw XT_COMPILE
000d33 0866          .dw XT_EDEFERSTORE
000d34 01b4          .dw XT_CELLPLUS
000d35 0853          .dw XT_DOTO
000d36 01fb          .dw PFA_EDP
000d37 f020          .dw XT_EXIT
                 .include "words/rdefer.asm"
                 
                 ; Compiler
                 ; creates a RAM based defer vector
                 VE_RDEFER:
000d38 ff06          .dw $ff06
000d39 6452
000d3a 6665
000d3b 7265          .db "Rdefer"
000d3c 0d23          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFER
                 XT_RDEFER:
000d3d f000          .dw DO_COLON
                 PFA_RDEFER:
000d3e 0217          .dw XT_DOCREATE
000d3f 0e37          .dw XT_REVEAL
                 
000d40 0249          .dw XT_COMPILE
000d41 089d          .dw PFA_DODEFER
                 
000d42 0202          .dw XT_HERE
000d43 0254          .dw XT_COMMA
000d44 f040          .dw XT_DOLITERAL
000d45 0002          .dw 2
000d46 020b          .dw XT_ALLOT
                 
000d47 0249          .dw XT_COMPILE
000d48 086b          .dw XT_RDEFERFETCH
000d49 0249          .dw XT_COMPILE
000d4a 0870          .dw XT_RDEFERSTORE
000d4b f020          .dw XT_EXIT
                 .include "words/is.asm"
                 
                 ; System
                 ; stores xt into defer or compiles code to do so at runtime
                 VE_IS:
000d4c 0002          .dw $0002
000d4d 7369          .db "is"
000d4e 0d38          .dw VE_HEAD
                     .set VE_HEAD = VE_IS
                 XT_IS:
000d4f f000          .dw DO_COLON
                 PFA_IS:
000d50 019f          .dw XT_STATE
000d51 f082          .dw XT_FETCH
000d52 f039          .dw XT_DOCONDBRANCH
000d53 0d58          .dw PFA_IS1
000d54 0260          .dw XT_BRACKETTICK
000d55 0249          .dw XT_COMPILE
000d56 0888          .dw XT_DEFERSTORE
000d57 f020          .dw XT_EXIT
                 PFA_IS1:
000d58 04e2          .dw XT_TICK
000d59 0888          .dw XT_DEFERSTORE
000d5a f020          .dw XT_EXIT
                 
                 .include "dict_compiler.inc"
                 
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 VE_LITERAL:
000d5b 0007          .dw $0007
000d5c 696c
000d5d 6574
000d5e 6172
000d5f 006c          .db "literal",0
000d60 0d4c          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
000d61 f000          .dw DO_COLON
                 PFA_LITERAL:
000d62 0249          .dw XT_COMPILE
000d63 f040          .dw XT_DOLITERAL
000d64 0254          .dw XT_COMMA
000d65 f020          .dw XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 VE_SLITERAL:
000d66 0008        .dw $0008
000d67 6c73
000d68 7469
000d69 7265
000d6a 6c61        .db "sliteral"
000d6b 0d5b        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
000d6c f000          .dw DO_COLON
                 PFA_SLITERAL:
000d6d 0249          .dw XT_COMPILE
000d6e 0443          .dw XT_DOSLITERAL    ; ( -- addr n)
000d6f 0456          .dw XT_SCOMMA
000d70 f020          .dw XT_EXIT
                 .include "words/g_mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
000d71 f000          .dw DO_COLON
                 PFA_GMARK:
000d72 01f2          .dw XT_DP
000d73 0249          .dw XT_COMPILE
000d74 ffff          .dw -1           ; ffff does not erase flash
000d75 f020          .dw XT_EXIT
                 .include "words/g_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
000d76 f000          .dw DO_COLON
                 PFA_GRESOLVE:
000d77 07f6          .dw XT_QSTACK
000d78 01f2          .dw XT_DP
000d79 f0cd          .dw XT_SWAP
000d7a f379          .dw XT_STOREI
000d7b f020          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
000d7c f000          .dw DO_COLON
                 PFA_LMARK:
000d7d 01f2          .dw XT_DP
000d7e f020          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
000d7f f000          .dw DO_COLON
                 PFA_LRESOLVE:
000d80 07f6          .dw XT_QSTACK
000d81 0254          .dw XT_COMMA
000d82 f020          .dw XT_EXIT
                 ; .include "words/qpairs.asm"
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 VE_AHEAD:
000d83 0005          .dw $0005
000d84 6861
000d85 6165
000d86 0064          .db "ahead",0
000d87 0d66          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
000d88 f000          .dw DO_COLON
                 PFA_AHEAD:
000d89 0249          .dw XT_COMPILE
000d8a f02f          .dw XT_DOBRANCH
000d8b 0d71          .dw XT_GMARK
000d8c f020          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 VE_IF:
000d8d 0002          .dw $0002
000d8e 6669          .db "if"
000d8f 0d83          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
000d90 f000          .dw DO_COLON
                 PFA_IF:
000d91 0249          .dw XT_COMPILE
000d92 f039          .dw XT_DOCONDBRANCH
000d93 0d71          .dw XT_GMARK
000d94 f020          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 VE_ELSE:
000d95 0004          .dw $0004
000d96 6c65
000d97 6573          .db "else"
000d98 0d8d          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
000d99 f000          .dw DO_COLON
                 PFA_ELSE:
000d9a 0249          .dw XT_COMPILE
000d9b f02f          .dw XT_DOBRANCH
000d9c 0d71          .dw XT_GMARK
000d9d f0cd          .dw XT_SWAP
000d9e 0d76          .dw XT_GRESOLVE
000d9f f020          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 VE_THEN:
000da0 0004          .dw $0004
000da1 6874
000da2 6e65          .db "then"
000da3 0d95          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
000da4 f000          .dw DO_COLON
                 PFA_THEN:
000da5 0d76          .dw XT_GRESOLVE
000da6 f020          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 VE_BEGIN:
000da7 0005          .dw $0005
000da8 6562
000da9 6967
000daa 006e          .db "begin",0
000dab 0da0          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
000dac f000          .dw DO_COLON
                 PFA_BEGIN:
000dad 0d7c          .dw XT_LMARK
000dae f020          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 VE_WHILE:
000daf 0005          .dw $0005
000db0 6877
000db1 6c69
000db2 0065          .db "while",0
000db3 0da7          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
000db4 f000          .dw DO_COLON
                 PFA_WHILE:
000db5 0249          .dw XT_COMPILE
000db6 f039          .dw XT_DOCONDBRANCH
000db7 0d71          .dw XT_GMARK
000db8 f0cd          .dw XT_SWAP
000db9 f020          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 VE_REPEAT:
000dba 0006          .dw $0006
000dbb 6572
000dbc 6570
000dbd 7461          .db "repeat"
000dbe 0daf          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
000dbf f000          .dw DO_COLON
                 PFA_REPEAT:
000dc0 0dd2          .dw XT_AGAIN
000dc1 0d76          .dw XT_GRESOLVE
000dc2 f020          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 VE_UNTIL:
000dc3 0005          .dw $0005
000dc4 6e75
000dc5 6974
000dc6 006c          .db "until",0
000dc7 0dba          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
000dc8 f000          .dw DO_COLON
                 PFA_UNTIL:
000dc9 0249          .dw XT_COMPILE
000dca f039          .dw XT_DOCONDBRANCH
000dcb 0d7f          .dw XT_LRESOLVE
000dcc f020          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 VE_AGAIN:
000dcd 0005          .dw $0005
000dce 6761
000dcf 6961
000dd0 006e          .db "again",0
000dd1 0dc3          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
000dd2 f000          .dw DO_COLON
                 PFA_AGAIN:
000dd3 0249          .dw XT_COMPILE
000dd4 f02f          .dw XT_DOBRANCH
000dd5 0d7f          .dw XT_LRESOLVE
000dd6 f020          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 VE_DO:
000dd7 0002          .dw $0002
000dd8 6f64          .db "do"
000dd9 0dcd          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000dda f000          .dw DO_COLON
                 PFA_DO:
000ddb 0249          .dw XT_COMPILE
000ddc f2a4          .dw XT_DODO
000ddd 0d71          .dw XT_GMARK
000dde 0d7c          .dw XT_LMARK
000ddf f020          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 VE_LOOP:
000de0 0004          .dw $0004
000de1 6f6c
000de2 706f          .db "loop"
000de3 0dd7          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
000de4 f000          .dw DO_COLON
                 PFA_LOOP:
000de5 0249          .dw XT_COMPILE
000de6 f2ea          .dw XT_DOLOOP
000de7 0d7f          .dw XT_LRESOLVE
000de8 0d76          .dw XT_GRESOLVE
000de9 f020          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 VE_PLUSLOOP:
000dea 0005          .dw $0005
000deb 6c2b
000dec 6f6f
000ded 0070          .db "+loop",0
000dee 0de0          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
000def f000          .dw DO_COLON
                 PFA_PLUSLOOP:
000df0 0249          .dw XT_COMPILE
000df1 f2d0          .dw XT_DOPLUSLOOP
000df2 0d7f          .dw XT_LRESOLVE
000df3 0d76          .dw XT_GRESOLVE
000df4 f020          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 VE_LEAVE:
000df5 ff05         .dw $FF05
000df6 656c
000df7 7661
000df8 0065         .db "leave",0
000df9 0dea         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
000dfa 0dfb          .dw PFA_LEAVE
                 PFA_LEAVE:
000dfb 910f          pop temp0  ; drop limit and counter from returnstack
000dfc 911f          pop temp1
000dfd 910f          pop temp0
000dfe 911f          pop temp1
000dff 91af          pop xl
000e00 91bf          pop xh
000e01 940c f004     jmp_ DO_NEXT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 VE_QDO:
000e03 0003          .dw $0003
000e04 643f
000e05 006f          .db "?do",0
000e06 0df5          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
000e07 f000          .dw DO_COLON
                 PFA_QDO:
000e08 0249          .dw XT_COMPILE
000e09 f2b9          .dw XT_DOQDO
000e0a 0d71          .dw XT_GMARK
000e0b 0d7c          .dw XT_LMARK
000e0c f020          .dw XT_EXIT
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
000e0d ff06          .dw $ff06
000e0e 7263
000e0f 6165
000e10 6574          .db "create"
000e11 0e03          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
000e12 f000          .dw DO_COLON
                 PFA_CREATE:
000e13 0217          .dw XT_DOCREATE
000e14 0e37          .dw XT_REVEAL
000e15 0249          .dw XT_COMPILE
000e16 f05b          .dw PFA_DOCONSTANT
000e17 f020          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
000e18 ff06          .dw $ff06
000e19 6568
000e1a 6461
000e1b 7265          .db "header"
000e1c 0e0d          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
000e1d f000          .dw DO_COLON
                 PFA_HEADER:
000e1e 01f2          .dw XT_DP           ; the new Name Field
000e1f f101          .dw XT_TO_R
000e20 f101          .dw XT_TO_R		; ( R: NFA WID )
000e21 f0ba          .dw XT_DUP    
000e22 f173          .dw XT_GREATERZERO 
000e23 f039          .dw XT_DOCONDBRANCH
000e24 0e2f          .dw PFA_HEADER1
000e25 f0ba          .dw XT_DUP
000e26 f040          .dw XT_DOLITERAL
000e27 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
000e28 f231          .dw XT_OR
000e29 045a          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
000e2a f0f8          .dw XT_R_FROM
000e2b f365          .dw XT_FETCHE
000e2c 0254          .dw XT_COMMA
000e2d f0f8          .dw XT_R_FROM
000e2e f020          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
000e2f f040          .dw XT_DOLITERAL
000e30 fff0          .dw -16
000e31 050f          .dw XT_THROW
                 
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
000e32 ff06          .dw $ff06
000e33 6572
000e34 6576
000e35 6c61          .db "reveal"
000e36 0e18          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
000e37 f000          .dw DO_COLON
                 PFA_REVEAL:
000e38 f040          .dw XT_DOLITERAL
000e39 028b          .dw COLON_SMUDGE+0
000e3a f082          .dw XT_FETCH
000e3b f0c2          .dw XT_QDUP
000e3c f039          .dw XT_DOCONDBRANCH
000e3d 0e46          .dw PFA_REVEAL1
                 ;
000e3e f040          .dw XT_DOLITERAL
000e3f 028d          .dw COLON_SMUDGE+2
000e40 f082          .dw XT_FETCH		; ( NFA WID )
000e41 f349          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
000e42 f14b          .dw XT_ZERO
000e43 f040          .dw XT_DOLITERAL
000e44 028b          .dw COLON_SMUDGE+0
000e45 f08a          .dw XT_STORE
                 PFA_REVEAL1:
000e46 f020          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
000e47 ff06          .dw $ff06
000e48 616c
000e49 6574
000e4a 7473          .db "latest"
000e4b 0e32          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
000e4c f04e          .dw PFA_DOVARIABLE
                 PFA_LATEST:
000e4d 031d          .dw ram_LATEST
                 
                 .dseg
00031d           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
000e4e 0005          .dw $0005
000e4f 6f64
000e50 7365
000e51 003e          .db "does>",0
000e52 0e47          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000e53 f000          .dw DO_COLON
                 PFA_DOES:
000e54 0249          .dw XT_COMPILE
000e55 0e66          .dw XT_DODOES
000e56 0249          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
000e57 940e          .dw $940e       ; the address of this compiled
000e58 0249          .dw XT_COMPILE  ; code will replace the XT of the 
000e59 0e5b          .dw DO_DODOES   ; word that CREATE created
000e5a f020          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
000e5b 939a
000e5c 938a          savetos
000e5d 01cb          movw tosl, wl
000e5e 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
000e5f 917f          pop wh
000e60 916f          pop wl
                 
000e61 93bf          push XH
000e62 93af          push XL
000e63 01db          movw XL, wl
000e64 940c f004     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
000e66 f000          .dw DO_COLON
                 PFA_DODOES:
000e67 f0f8          .dw XT_R_FROM
000e68 0fb9          .dw XT_GET_CURRENT
000e69 f365          .dw XT_FETCHE
000e6a 0ff8          .dw XT_NFA2LFA
000e6b f244          .dw XT_1PLUS   ; lfa>xt
                 
000e6c f379          .dw XT_STOREI
000e6d f020          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 VE_COLON:
000e6e ff01          .dw $ff01
000e6f 003a          .db ":",0
000e70 0e4e          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000e71 f000          .dw DO_COLON
                 PFA_COLON:
000e72 0217          .dw XT_DOCREATE
000e73 01f2          .dw XT_DP
000e74 0e4c          .dw XT_LATEST
000e75 f08a          .dw XT_STORE
000e76 0249          .dw XT_COMPILE
000e77 f000          .dw DO_COLON
000e78 0e95          .dw XT_RBRACKET
000e79 f020          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
000e7a ff07          .dw $ff07
000e7b 6e3a
000e7c 6e6f
000e7d 6d61
000e7e 0065          .db ":noname",0
000e7f 0e6e          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000e80 f000          .dw DO_COLON
                 PFA_COLONNONAME:
000e81 01f2          .dw XT_DP
000e82 f0ba          .dw XT_DUP
000e83 0e4c          .dw XT_LATEST
000e84 f08a          .dw XT_STORE
                 
000e85 0249          .dw XT_COMPILE
000e86 f000          .dw DO_COLON
                 
000e87 0e95          .dw XT_RBRACKET
000e88 f020          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 VE_SEMICOLON:
000e89 0001          .dw $0001
000e8a 003b          .db $3b,0
000e8b 0e7a          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
000e8c f000          .dw DO_COLON
                 PFA_SEMICOLON:
000e8d 0249          .dw XT_COMPILE
000e8e f020          .dw XT_EXIT
000e8f 0e9e          .dw XT_LBRACKET
000e90 0e37          .dw XT_REVEAL
000e91 f020          .dw XT_EXIT
                 .include "words/rightbracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 VE_RBRACKET:
000e92 ff01          .dw $ff01
000e93 005d          .db "]",0
000e94 0e89          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000e95 f000          .dw DO_COLON
                 PFA_RBRACKET:
000e96 f040          .dw XT_DOLITERAL
000e97 0001          .dw 1
000e98 019f          .dw XT_STATE
000e99 f08a          .dw XT_STORE
000e9a f020          .dw XT_EXIT
                 .include "words/leftbracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 VE_LBRACKET:
000e9b 0001          .dw $0001
000e9c 005b          .db "[",0
000e9d 0e92          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
000e9e f000          .dw DO_COLON
                 PFA_LBRACKET:
000e9f f14b          .dw XT_ZERO
000ea0 019f          .dw XT_STATE
000ea1 f08a          .dw XT_STORE
000ea2 f020          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 VE_VARIABLE:
000ea3 ff08          .dw $ff08
000ea4 6176
000ea5 6972
000ea6 6261
000ea7 656c          .db "variable"
000ea8 0e9b          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000ea9 f000          .dw DO_COLON
                 PFA_VARIABLE:
000eaa 0202          .dw XT_HERE
000eab 0eb6          .dw XT_CONSTANT
000eac f040          .dw XT_DOLITERAL
000ead 0002          .dw 2
000eae 020b          .dw XT_ALLOT
000eaf f020          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 VE_CONSTANT:
000eb0 ff08          .dw $ff08
000eb1 6f63
000eb2 736e
000eb3 6174
000eb4 746e          .db "constant"
000eb5 0ea3          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000eb6 f000          .dw DO_COLON
                 PFA_CONSTANT:
000eb7 0217          .dw XT_DOCREATE
000eb8 0e37          .dw XT_REVEAL
000eb9 0249          .dw XT_COMPILE
000eba f04e          .dw PFA_DOVARIABLE
000ebb 0254          .dw XT_COMMA
000ebc f020          .dw XT_EXIT
                 
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
000ebd ff04          .dw $ff04
000ebe 7375
000ebf 7265          .db "user"
000ec0 0eb0          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
000ec1 f000          .dw DO_COLON
                 PFA_USER:
000ec2 0217          .dw XT_DOCREATE
000ec3 0e37          .dw XT_REVEAL
                 
000ec4 0249          .dw XT_COMPILE
000ec5 f061          .dw PFA_DOUSER
000ec6 0254          .dw XT_COMMA
000ec7 f020          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
000ec8 0007          .dw $0007
000ec9 6572
000eca 7563
000ecb 7372
000ecc 0065          .db "recurse",0
000ecd 0ebd          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
000ece f000          .dw DO_COLON
                 PFA_RECURSE:
000ecf 0e4c          .dw XT_LATEST
000ed0 f082          .dw XT_FETCH
000ed1 0254          .dw XT_COMMA
000ed2 f020          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
000ed3 ff09          .dw $ff09
000ed4 6d69
000ed5 656d
000ed6 6964
000ed7 7461
000ed8 0065          .db "immediate",0
000ed9 0ec8          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
000eda f000          .dw DO_COLON
                 PFA_IMMEDIATE:
000edb 0fb9          .dw XT_GET_CURRENT
000edc f365          .dw XT_FETCHE
000edd f0ba          .dw XT_DUP
000ede f3d7          .dw XT_FETCHI
000edf f040          .dw XT_DOLITERAL
000ee0 7fff          .dw $7fff
000ee1 f228          .dw XT_AND
000ee2 f0cd          .dw XT_SWAP
000ee3 f379          .dw XT_STOREI
000ee4 f020          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 VE_BRACKETCHAR:
000ee5 0006          .dw $0006
000ee6 635b
000ee7 6168
000ee8 5d72          .db "[char]"
000ee9 0ed3          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
000eea f000          .dw DO_COLON
                 PFA_BRACKETCHAR:
000eeb 0249          .dw XT_COMPILE
000eec f040          .dw XT_DOLITERAL
000eed 0593          .dw XT_CHAR
000eee 0254          .dw XT_COMMA
000eef f020          .dw XT_EXIT
                 .include "words/abortstring.asm"
                 
                 ; Exceptions
                 ; check flag. If true display the parsed text and throw exception -2 
                 VE_ABORTSTRING:
000ef0 0006          .dw $0006
000ef1 6261
000ef2 726f
000ef3 2274          .db "abort", $22
000ef4 0ee5          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTSTRING
                 XT_ABORTSTRING:
000ef5 f000          .dw DO_COLON
                 PFA_ABORTSTRING:
                     ; postpone if
000ef6 0249          .dw XT_COMPILE
000ef7 f039          .dw XT_DOCONDBRANCH
000ef8 01f2          .dw XT_DP
000ef9 0249          .dw XT_COMPILE
000efa ffff          .dw -1
                     
000efb 0cf2          .dw XT_DOTSTRING
                     
000efc 0249          .dw XT_COMPILE
000efd f040          .dw XT_DOLITERAL
                     
000efe 0249          .dw XT_COMPILE
000eff fffe          .dw -2
000f00 0249          .dw XT_COMPILE
000f01 050f          .dw XT_THROW
                     ; then
000f02 01f2          .dw XT_DP
000f03 f0cd          .dw XT_SWAP
000f04 f379          .dw XT_STOREI
000f05 f020          .dw XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 VE_ABORT:
000f06 ff05          .dw $ff05
000f07 6261
000f08 726f
000f09 0074          .db "abort",0
000f0a 0ef0          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
000f0b f000          .dw DO_COLON
                 PFA_ABORT:
000f0c f040          .dw XT_DOLITERAL
000f0d ffff          .dw -1
000f0e 050f          .dw XT_THROW
                 
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000f0f ff04          .dw $ff04
000f10 6f63
000f11 6564          .db "code"
000f12 0f06          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
000f13 f000          .dw DO_COLON
                 PFA_CODE:
000f14 0217          .dw XT_DOCREATE
000f15 0e37          .dw XT_REVEAL
000f16 01f2          .dw XT_DP
000f17 f244          .dw XT_1PLUS
000f18 0254          .dw XT_COMMA
000f19 f020          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000f1a ff08          .dw $ff08
000f1b 6e65
000f1c 2d64
000f1d 6f63
000f1e 6564          .db "end-code"
000f1f 0f0f          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000f20 f000          .dw DO_COLON
                 PFA_ENDCODE:
000f21 0249          .dw XT_COMPILE
000f22 940c          .dw $940c
000f23 0249          .dw XT_COMPILE
000f24 f004          .dw DO_NEXT
000f25 f020          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
000f26 ff0b          .dw $ff0b
000f27 6e65
000f28 6976
000f29 6f72
000f2a 6d6e
000f2b 6e65
000f2c 0074          .db "environment",0
000f2d 0f1a          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
000f2e f04e          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
000f2f 000e          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
000f30 ff09          .dw $ff09
000f31 6f77
000f32 6472
000f33 696c
000f34 7473
000f35 0073          .db "wordlists",0
000f36 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
000f37 f000          .dw DO_COLON
                 PFA_ENVWORDLISTS:
000f38 f040          .dw XT_DOLITERAL
000f39 0008          .dw NUMWORDLISTS
000f3a f020          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
000f3b ff04          .dw $ff04
000f3c 702f
000f3d 6461          .db "/pad"
000f3e 0f30          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
000f3f f000          .dw DO_COLON
                 PFA_ENVSLASHPAD:
000f40 f296          .dw XT_SP_FETCH
000f41 01c8          .dw XT_PAD
000f42 f1a8          .dw XT_MINUS
000f43 f020          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
000f44 ff05          .dw $ff05
000f45 682f
000f46 6c6f
000f47 0064          .db "/hold",0
000f48 0f3b          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
000f49 f000          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
000f4a 01c8          .dw XT_PAD
000f4b 0202          .dw XT_HERE
000f4c f1a8          .dw XT_MINUS
000f4d f020          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 VE_ENV_FORTHNAME:
000f4e ff0a          .dw $ff0a
000f4f 6f66
000f50 7472
000f51 2d68
000f52 616e
000f53 656d          .db "forth-name"
000f54 0f44          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
000f55 f000          .dw DO_COLON
                 PFA_EN_FORTHNAME:
000f56 0443          .dw XT_DOSLITERAL
000f57 0007          .dw 7
000f58 6d61
000f59 6f66
000f5a 7472
000f5b 0068          .db "amforth",0
000f5c f020          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 VE_ENV_FORTHVERSION:
000f5d ff07          .dw $ff07
000f5e 6576
000f5f 7372
000f60 6f69
000f61 006e          .db "version",0
000f62 0f4e          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
000f63 f000          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
000f64 f040          .dw XT_DOLITERAL
000f65 0033          .dw 51
000f66 f020          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 VE_ENV_CPU:
000f67 ff03          .dw $ff03
000f68 7063
000f69 0075          .db "cpu",0
000f6a 0f5d          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
000f6b f000          .dw DO_COLON
                 PFA_EN_CPU:
000f6c f040          .dw XT_DOLITERAL
000f6d 0075          .dw mcu_name
000f6e 04a5          .dw XT_ICOUNT
000f6f f020          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
000f70 ff08          .dw $ff08
000f71 636d
000f72 2d75
000f73 6e69
000f74 6f66          .db "mcu-info"
000f75 0f67          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
000f76 f000          .dw DO_COLON
                 PFA_EN_MCUINFO:
000f77 f040          .dw XT_DOLITERAL
000f78 0071          .dw mcu_info
000f79 f020          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
000f7a ff05          .dw $ff05
000f7b 752f
000f7c 6573
000f7d 0072          .db "/user",0
000f7e 0f70          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
000f7f f000          .dw DO_COLON
                 PFA_ENVUSERSIZE:
000f80 f040          .dw XT_DOLITERAL
000f81 0026          .dw SYSUSERSIZE + APPUSERSIZE
000f82 f020          .dw XT_EXIT
                 
                 .include "words/fetch-ee-array.asm"
                 
                 ; Tools
                 ; Get an array from EEPROM
                 VE_FETCH_EE_ARRAY:
000f83 ff04          .dw $ff04
000f84 6540
000f85 5d5b          .db "@e[]"
000f86 0f26          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH_EE_ARRAY
                 XT_FETCH_EE_ARRAY:
000f87 f000          .dw DO_COLON
                 PFA_FETCH_EE_ARRAY:
000f88 f0ba          .dw XT_DUP
000f89 f365          .dw XT_FETCHE
000f8a f101          .dw XT_TO_R    ; save the counter to r-stack
000f8b f10a          .dw XT_R_FETCH
000f8c f14b          .dw XT_ZERO
000f8d f0cd          .dw XT_SWAP    ; go from bigger to smaller addresses
000f8e f2b9          .dw XT_DOQDO
000f8f 0f99          .dw PFA_FETCH_EE_ARRAY2
                 PFA_FETCH_EE_ARRAY1:
                     ; ( ee-addr )
000f90 f2cf          .dw XT_I
000f91 01ac          .dw XT_CELLS ; ( -- ee-addr i*2 )
000f92 f0d8          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
000f93 f1b2          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
000f94 f365          .dw XT_FETCHE ;( -- ee-addr item_i )
000f95 f0cd          .dw XT_SWAP   ;( -- item_i ee-addr )
000f96 f154          .dw XT_TRUE  ; shortcut for -1
000f97 f2d0          .dw XT_DOPLUSLOOP
000f98 0f90          .dw PFA_FETCH_EE_ARRAY1
                 PFA_FETCH_EE_ARRAY2:
000f99 f0e2          .dw XT_DROP
000f9a f0e2          .dw XT_DROP
000f9b f0f8          .dw XT_R_FROM ; get the counter from r-stack
000f9c f020          .dw XT_EXIT
                 
                 .include "words/store-ee-array.asm"
                 
                 ; Tools
                 ; Write a list to EEPROM
                 VE_STORE_EE_ARRAY:
000f9d ff04          .dw $ff04
000f9e 6521
000f9f 5d5b          .db "!e[]"
000fa0 0f83          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE_EE_ARRAY
                 XT_STORE_EE_ARRAY:
000fa1 f000          .dw DO_COLON
                 PFA_STORE_EE_ARRAY:
000fa2 f0d8          .dw XT_OVER
000fa3 f0d8          .dw XT_OVER
000fa4 f349          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
000fa5 f0cd          .dw XT_SWAP    
000fa6 f14b          .dw XT_ZERO
000fa7 f2b9          .dw XT_DOQDO
000fa8 0faf          .dw PFA_STORE_EE_ARRAY2
                 PFA_STORE_EE_ARRAY1:
000fa9 01b4          .dw XT_CELLPLUS ; ( -- i_x e-addr )
000faa f0cd          .dw XT_SWAP
000fab f0d8          .dw XT_OVER      ; ( -- e-addr i_x e-addr
000fac f349          .dw XT_STOREE
000fad f2ea          .dw XT_DOLOOP
000fae 0fa9          .dw PFA_STORE_EE_ARRAY1
                 PFA_STORE_EE_ARRAY2:
000faf f0e2          .dw XT_DROP
000fb0 f020          .dw XT_EXIT
                 
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000fb1 ff0b          .dw $ff0b
000fb2 6567
000fb3 2d74
000fb4 7563
000fb5 7272
000fb6 6e65
000fb7 0074          .db "get-current",0
000fb8 0f9d          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
000fb9 f000          .dw DO_COLON
                 PFA_GET_CURRENT:
000fba f040          .dw XT_DOLITERAL
000fbb 0012          .dw EE_CURRENT
000fbc f365          .dw XT_FETCHE
000fbd f020          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 VE_GET_ORDER:
000fbe ff09          .dw $ff09
000fbf 6567
000fc0 2d74
000fc1 726f
000fc2 6564
000fc3 0072          .db "get-order",0
000fc4 0fb1          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
000fc5 f000          .dw DO_COLON
                 PFA_GET_ORDER:
000fc6 f040          .dw XT_DOLITERAL
000fc7 0016          .dw EE_ORDERLISTLEN
000fc8 0f87          .dw XT_FETCH_EE_ARRAY
000fc9 f020          .dw XT_EXIT
                 ;.include "words/set-recognizer.asm"
                 ;.include "words/get-recognizer.asm"
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000fca ff07          .dw $ff07
000fcb 6f63
000fcc 706d
000fcd 7261
000fce 0065          .db "compare",0
000fcf 0fbe          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
000fd0 0fd1          .dw PFA_COMPARE
                 PFA_COMPARE:
000fd1 93bf          push xh
000fd2 93af          push xl
000fd3 018c          movw temp0, tosl
000fd4 9189
000fd5 9199          loadtos
000fd6 01dc          movw xl, tosl
000fd7 9189
000fd8 9199          loadtos
000fd9 019c          movw temp2, tosl
000fda 9189
000fdb 9199          loadtos
000fdc 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000fdd 90ed          ld temp4, X+
000fde 90f1          ld temp5, Z+
000fdf 14ef          cp temp4, temp5
000fe0 f451          brne PFA_COMPARE_NOTEQUAL
000fe1 950a          dec temp0
000fe2 f019          breq PFA_COMPARE_ENDREACHED2
000fe3 952a          dec temp2
000fe4 f7c1          brne PFA_COMPARE_LOOP
000fe5 c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000fe6 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000fe7 2b02          or temp0, temp2
000fe8 f411          brne PFA_COMPARE_CHECKLASTCHAR
000fe9 2788          clr tosl
000fea c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000feb ef8f          ser tosl
000fec c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000fed 2f98          mov tosh, tosl
000fee 91af          pop xl
000fef 91bf          pop xh
000ff0 940c f004     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
000ff2 ff07         .dw $ff07
000ff3 666e
000ff4 3e61
000ff5 666c
000ff6 0061         .db "nfa>lfa",0
000ff7 0fca         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000ff8 f000          .dw DO_COLON
                 PFA_NFA2LFA:
000ff9 04a5          .dw XT_ICOUNT 
000ffa f040          .dw XT_DOLITERAL
000ffb 00ff          .dw $00ff
000ffc f228          .dw XT_AND
000ffd f244          .dw XT_1PLUS
000ffe f219          .dw XT_2SLASH
000fff f1b2          .dw XT_PLUS
001000 f020          .dw XT_EXIT
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 VE_SHOWWORDLIST:
001001 ff0d          .dw $ff0d
001002 6873
001003 776f
001004 772d
001005 726f
001006 6c64
001007 7369
001008 0074          .db "show-wordlist",0
001009 0ff2          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
00100a f000          .dw DO_COLON
                 PFA_SHOWWORDLIST:
00100b f365          .dw XT_FETCHE
                 PFA_SHOWWORDLIST3:
00100c f0c2          .dw XT_QDUP           ; ( -- addr addr )
00100d f039          .dw XT_DOCONDBRANCH  ; ( -- addr ) is nfa = counted string
00100e 101a          .dw PFA_SHOWWORDLIST2       ;
00100f f0ba          .dw XT_DUP
001010 04a5          .dw XT_ICOUNT   ; ( -- addr n )
001011 f040          .dw XT_DOLITERAL
001012 00ff          .dw $00FF
001013 f228          .dw XT_AND      ; mask immediate bit
001014 047a          .dw XT_ITYPE
001015 04bb          .dw XT_SPACE         ; ( -- addr n)
001016 0ff8          .dw XT_NFA2LFA
001017 f3d7          .dw XT_FETCHI        ; ( -- addr )
001018 f02f          .dw XT_DOBRANCH      ; ( -- addr )
001019 100c          .dw PFA_SHOWWORDLIST3       ; ( -- addr )
                 PFA_SHOWWORDLIST2:
00101a f020          .dw XT_EXIT
                 .include "dict_interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
00101b ff04          .dw $ff04
00101c 692b
00101d 746e          .db "+int"
00101e 1001          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
00101f 1020          .dw PFA_INTON
                 PFA_INTON:
001020 9478          sei
001021 940c f004     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
001023 ff04          .dw $ff04
001024 692d
001025 746e          .db "-int"
001026 101b          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
001027 1028          .dw PFA_INTOFF
                 PFA_INTOFF:
001028 94f8          cli
001029 940c f004     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
00102b ff04          .dw $ff04
00102c 6e69
00102d 2174          .db "int!"
00102e 1023          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
00102f f000          .dw DO_COLON
                 PFA_INTSTORE:
001030 f040          .dw XT_DOLITERAL
001031 0215          .dw intvec
001032 f1b2          .dw XT_PLUS
001033 f08a          .dw XT_STORE
001034 f020          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
001035 ff04          .dw $ff04
001036 6e69
001037 4074          .db "int@"
001038 102b          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
001039 f000          .dw DO_COLON
                 PFA_INTFETCH:
00103a f040          .dw XT_DOLITERAL
00103b 0215          .dw intvec
00103c f1b2          .dw XT_PLUS
00103d f082          .dw XT_FETCH
00103e f020          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
00103f ff08          .dw $ff08
001040 6e69
001041 2d74
001042 7274
001043 7061          .db "int-trap"
001044 1035          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
001045 1046          .dw PFA_INTTRAP
                 PFA_INTTRAP:
001046 9380 0214     sts intcur, tosl
001048 9189
001049 9199          loadtos
00104a 9468          set ; set the interrupt flag for the inner interpreter
00104b 940c f004     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
00104d f000          .dw DO_COLON
                 PFA_ISREXEC:
00104e f040          .dw XT_DOLITERAL
00104f 0214          .dw intcur
001050 f0a1          .dw XT_CFETCH
001051 f040          .dw XT_DOLITERAL
001052 0215          .dw intvec
001053 f1b2          .dw XT_PLUS
001054 f082          .dw XT_FETCH
001055 f02a          .dw XT_EXECUTE
001056 105e          .dw XT_ISREND
001057 f020          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ;  Interrupt
                 ; re-enables interrupts in an ISR
                 VE_ISREND:
001058 ff07          .dw $ff07
001059 7369
00105a 2d72
00105b 6e65
00105c 0064          .db "isr-end",0
00105d 103f          .dw VE_HEAD
                     .set VE_HEAD = VE_ISREND
                 XT_ISREND:
00105e 105f          .dw PFA_ISREND
                 PFA_ISREND:
00105f d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
001060 940c f004     jmp_ DO_NEXT
                 PFA_ISREND1:
001062 9518          reti
                 
                 ; include some controller specific definitions
                 .include "device.inc"
                 
                 ; generated automatically, no not edit
                 
                 .if WANT_ANALOG_COMPARATOR == 1
                 .endif
                 .if WANT_USART0 == 1
                 .endif
                 .if WANT_USART1 == 1
                 .endif
                 .if WANT_TWI == 1
                 .endif
                 .if WANT_SPI == 1
                 .endif
                 .if WANT_PORTA == 1
                 .endif
                 .if WANT_PORTB == 1
                 .endif
                 .if WANT_PORTC == 1
                 .endif
                 .if WANT_PORTD == 1
                 .endif
                 .if WANT_PORTE == 1
                 .endif
                 .if WANT_PORTF == 1
                 .endif
                 .if WANT_PORTG == 1
                 .endif
                 .if WANT_TIMER_COUNTER_0 == 1
                 .endif
                 .if WANT_TIMER_COUNTER_2 == 1
                 .endif
                 .if WANT_WATCHDOG == 1
                 .endif
                 .if WANT_TIMER_COUNTER_5 == 1
                 .endif
                 .if WANT_TIMER_COUNTER_4 == 1
                 .endif
                 .if WANT_TIMER_COUNTER_3 == 1
                 .endif
                 .if WANT_TIMER_COUNTER_1 == 1
                 .endif
                 .if WANT_EEPROM == 1
                 .endif
                 .if WANT_JTAG == 1
                 .endif
                 .if WANT_EXTERNAL_INTERRUPT == 1
                 .endif
                 .if WANT_AD_CONVERTER == 1
                 .endif
                 .if WANT_BOOT_LOAD == 1
                 .endif
                 .if WANT_CPU == 1
                 .endif
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
001063 ff0b          .dw $ff0b
001064 7061
001065 6c70
001066 7574
001067 6e72
001068 656b
001069 0079          .db "applturnkey",0
00106a 1058          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
00106b f000          .dw DO_COLON
                 PFA_APPLTURNKEY:
00106c 00ee          .dw XT_USART
00106d 101f          .dw XT_INTON
00106e 0803          .dw XT_VER
00106f f020          .dw XT_EXIT
                 .include "words/qmark.asm"
                 
                 ; R( -- )
                 ; print the content of addr
                 VE_QMARK:
001070 ff01          .dw $ff01
001071 003f          .db "?",0 
001072 1063          .dw VE_HEAD
                     .set VE_HEAD = VE_QMARK
                 XT_QMARK:
001073 f000          .dw DO_COLON 
                 PFA_QMARK:
001074 f082          .dw XT_FETCH 
001075 03d9          .dw XT_DOT 
001076 f020          .dw XT_EXIT 
                 
                 ;    : ?     ( adr - n ) @ . ; 
                 
                 .include "dict_wl.inc"
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
001077 ff0b          .dw $ff0b
001078 6573
001079 2d74
00107a 7563
00107b 7272
00107c 6e65
00107d 0074          .db "set-current",0
00107e 1070          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
00107f f000          .dw DO_COLON
                 PFA_SET_CURRENT:
001080 f040          .dw XT_DOLITERAL
001081 0012          .dw EE_CURRENT
001082 f349          .dw XT_STOREE
001083 f020          .dw XT_EXIT
                 .include "words/previous.asm"
                 
                 ; Search Order
                 ; remove the first entry in the search order list
                 VE_PREVIOUS:
001084 ff08          .dw $ff08
001085 7270
001086 7665
001087 6f69
001088 7375          .db "previous"
001089 1077          .dw VE_HEAD
                     .set VE_HEAD = VE_PREVIOUS
                 XT_PREVIOUS:
00108a f000          .dw DO_COLON	
                 PFA_PREVIOUS:
00108b 0fc5          .dw XT_GET_ORDER
00108c f0cd          .dw XT_SWAP
00108d f0e2          .dw XT_DROP
00108e f24a          .dw XT_1MINUS
00108f f0ba          .dw XT_DUP
001090 f129          .dw XT_EQUALZERO
001091 f039          .dw XT_DOCONDBRANCH
001092 1096          .dw PFA_PREVIOUS1
001093 f040          .dw XT_DOLITERAL
001094 ffce          .dw -50
001095 050f          .dw XT_THROW
                 PFA_PREVIOUS1:
001096 10f3          .dw XT_SET_ORDER
001097 f020          .dw XT_EXIT
                 .include "words/definitions.asm"
                 
                 ; Search Order
                 ; Make the compilation word list the same as the current first word list in the search order.
                 VE_DEFINITIONS:
001098 ff0b          .dw $ff0b
001099 6564
00109a 6966
00109b 696e
00109c 6974
00109d 6e6f
00109e 0073          .db "definitions",0
00109f 1084          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFINITIONS
                 XT_DEFINITIONS:
0010a0 f000          .dw DO_COLON
                 PFA_DEFINITIONS:
0010a1 0fc5          .dw XT_GET_ORDER
0010a2 f0d8          .dw XT_OVER
0010a3 107f          .dw XT_SET_CURRENT
                     ; now empty the order list on stack
0010a4 f14b          .dw XT_ZERO
0010a5 f2b9          .dw XT_DOQDO
0010a6 10aa          .dw PFA_DEFINITIONS2
                 PFA_DEFINITIONS1:
0010a7 f0e2          .dw XT_DROP
0010a8 f2ea          .dw XT_DOLOOP
0010a9 10a7          .dw PFA_DEFINITIONS1
                 PFA_DEFINITIONS2:
0010aa f020          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
0010ab ff08          .dw $ff08
0010ac 6f77
0010ad 6472
0010ae 696c
0010af 7473          .db "wordlist"
0010b0 1098          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
0010b1 f000          .dw DO_COLON
                 PFA_WORDLIST:
0010b2 01fa          .dw XT_EDP
0010b3 f14b          .dw XT_ZERO
0010b4 f0d8          .dw XT_OVER
0010b5 f349          .dw XT_STOREE
0010b6 f0ba          .dw XT_DUP
0010b7 f244          .dw XT_1PLUS
0010b8 f244          .dw XT_1PLUS
0010b9 0853          .dw XT_DOTO
0010ba 01fb          .dw PFA_EDP
0010bb f020          .dw XT_EXIT
                 
                 .include "words/only.asm"
                 
                 ; Search Order
                 ; replace the order list with the system default list
                 VE_ONLY:
0010bc ff04          .dw $ff04
0010bd 6e6f
0010be 796c          .db "only"
0010bf 10ab          .dw VE_HEAD
                     .set VE_HEAD = VE_ONLY
                 XT_ONLY:
0010c0 f000          .dw DO_COLON
                 PFA_ONLY:
0010c1 f040          .dw XT_DOLITERAL
0010c2 0014          .dw EE_FORTHWORDLIST
0010c3 f040          .dw XT_DOLITERAL
0010c4 0001          .dw 1
0010c5 10f3          .dw XT_SET_ORDER
0010c6 f020          .dw XT_EXIT
                 .include "words/forth.asm"
                 
                 ; Search Order
                 ; replace the search order list with the system default list
                 VE_FORTH:
0010c7 ff05          .dw $ff05
0010c8 6f66
0010c9 7472
0010ca 0068          .db "forth",0
0010cb 10bc          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTH
                 XT_FORTH:
0010cc f000          .dw DO_COLON
                 PFA_FORTH:
0010cd 0fc5          .dw XT_GET_ORDER
0010ce f0cd          .dw XT_SWAP
0010cf f0e2          .dw XT_DROP
0010d0 10dd          .dw XT_FORTH_WORDLIST
0010d1 f0cd          .dw XT_SWAP
0010d2 10f3          .dw XT_SET_ORDER
0010d3 f020          .dw XT_EXIT
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTH_WORDLIST:
0010d4 ff0e          .dw $ff0e
0010d5 6f66
0010d6 7472
0010d7 2d68
0010d8 6f77
0010d9 6472
0010da 696c
0010db 7473          .db "forth-wordlist"
0010dc 10c7          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTH_WORDLIST
                 XT_FORTH_WORDLIST:
0010dd f076          .dw PFA_DOVALUE
                 PFA_FORTH_WORDLIST:
0010de 0010          .dw EE_WL_FORTH
0010df f365          .dw XT_FETCHE
0010e0 f349          .dw XT_STOREE
                 .include "words/also.asm"
                 
                 ; Search Order
                 ; Duplicate first entry in the current search order list
                 VE_ALSO:
0010e1 ff04          .dw $ff04
0010e2 6c61
0010e3 6f73          .db "also"
0010e4 10d4          .dw VE_HEAD
                     .set VE_HEAD = VE_ALSO
                 XT_ALSO:
0010e5 f000          .dw DO_COLON
                 PFA_ALSO:
0010e6 0fc5          .dw XT_GET_ORDER
0010e7 f0d8          .dw XT_OVER
0010e8 f0cd          .dw XT_SWAP
0010e9 f244          .dw XT_1PLUS
0010ea 10f3          .dw XT_SET_ORDER
0010eb f020          .dw XT_EXIT
                 .include "words/set-order.asm"
                 
                 ; Search Order
                 ; replace the search order list
                 VE_SET_ORDER:
0010ec ff09          .dw $ff09
0010ed 6573
0010ee 2d74
0010ef 726f
0010f0 6564
0010f1 0072          .db "set-order",0
0010f2 10e1          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_ORDER
                 XT_SET_ORDER:
0010f3 f000          .dw DO_COLON
                 PFA_SET_ORDER:
0010f4 f040          .dw XT_DOLITERAL
0010f5 0016          .dw EE_ORDERLISTLEN
0010f6 0fa1          .dw XT_STORE_EE_ARRAY
0010f7 f020          .dw XT_EXIT
                 
                 .include "words/order.asm"
                 
                 ; Search Order
                 ; print the wids of the current word list and the search order
                 VE_ORDER:
0010f8 ff05          .dw $ff05
0010f9 726f
0010fa 6564
0010fb 0072          .db "order",0
0010fc 10ec          .dw VE_HEAD
                     .set VE_HEAD = VE_ORDER
                 XT_ORDER:
0010fd f000          .dw DO_COLON
                 PFA_ORDER:
0010fe 0fb9          .dw XT_GET_CURRENT
0010ff 0cbf          .dw XT_UDOT
001100 04ae          .dw XT_CR
001101 0fc5          .dw XT_GET_ORDER
001102 f0ba          .dw XT_DUP
001103 0cbf          .dw XT_UDOT
001104 f14b          .dw XT_ZERO
001105 f2b9          .dw XT_DOQDO
001106 110b          .dw PFA_ORDER2
                 PFA_ORDER1:
001107 0cbf          .dw XT_UDOT
001108 04bb          .dw XT_SPACE         ; ( -- addr n)
001109 f2ea          .dw XT_DOLOOP
00110a 1107          .dw PFA_ORDER1
                 PFA_ORDER2:
00110b f020          .dw XT_EXIT
                 
                 
                 
                 .set DPSTART = pc
                 
                 .org NRWW_START_ADDR
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
00f000 93bf          push XH
00f001 93af          push XL          ; PUSH IP
00f002 01db          movw XL, wl
00f003 9611          adiw xl, 1
                 DO_NEXT:
00f004 f09e          brts DO_INTERRUPT
00f005 01fd          movw zl, XL        ; READ IP
00f006 2755
00f007 0fee
00f008 1fff
00f009 1f55
00f00a bf5b
00f00b 9167
00f00c 9177          readflashcell wl, wh
00f00d 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00f00e 01fb          movw zl, wl
00f00f 2755
00f010 0fee
00f011 1fff
00f012 1f55
00f013 bf5b
00f014 9107
00f015 9117          readflashcell temp0,temp1
00f016 01f8          movw zl, temp0
00f017 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
00f018 94e8          clt
00f019 e46d          ldi wl, LOW(XT_ISREXEC)
00f01a e170          ldi wh, HIGH(XT_ISREXEC)
00f01b cff2          rjmp DO_EXECUTE
                 .include "dict_appl_core.inc"
                 
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
00f01c ff04          .dw $ff04
00f01d 7865
00f01e 7469          .db "exit"
00f01f 10f8          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00f020 f021          .dw PFA_EXIT
                 PFA_EXIT:
00f021 91af          pop XL
00f022 91bf          pop XH
00f023 cfe0          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
00f024 ff07          .dw $ff07
00f025 7865
00f026 6365
00f027 7475
00f028 0065          .db "execute",0
00f029 f01c          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
00f02a f02b          .dw PFA_EXECUTE
                 PFA_EXECUTE:
00f02b 01bc          movw wl, tosl
00f02c 9189
00f02d 9199          loadtos
00f02e cfdf          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
00f02f f030          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00f030 01fd          movw zl, XL
00f031 2755
00f032 0fee
00f033 1fff
00f034 1f55
00f035 bf5b
00f036 91a7
00f037 91b7          readflashcell XL,XH
00f038 cfcb          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
00f039 f03a          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
00f03a 2b98          or tosh, tosl
00f03b 9189
00f03c 9199          loadtos
00f03d f391          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
00f03e 9611          adiw XL, 1
00f03f cfc4          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
00f040 f041          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
00f041 939a
00f042 938a          savetos
00f043 01fd          movw zl, xl
00f044 2755
00f045 0fee
00f046 1fff
00f047 1f55
00f048 bf5b
00f049 9187
00f04a 9197          readflashcell tosl,tosh
00f04b 9611          adiw xl, 1
00f04c cfb7          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
00f04d f04e          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
00f04e 939a
00f04f 938a          savetos
00f050 01fb          movw zl, wl
00f051 9631          adiw zl,1
00f052 2755
00f053 0fee
00f054 1fff
00f055 1f55
00f056 bf5b
00f057 9187
00f058 9197          readflashcell tosl,tosh
00f059 cfaa          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00f05a f05b          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00f05b 939a
00f05c 938a          savetos
00f05d 01cb          movw tosl, wl
00f05e 9601          adiw tosl, 1
00f05f cfa4          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
00f060 f061          .dw PFA_DOUSER
                 PFA_DOUSER:
00f061 939a
00f062 938a          savetos
00f063 01fb          movw zl, wl
00f064 9631          adiw zl, 1
00f065 2755
00f066 0fee
00f067 1fff
00f068 1f55
00f069 bf5b
00f06a 9187
00f06b 9197          readflashcell tosl,tosh
00f06c 0d84          add tosl, upl
00f06d 1d95          adc tosh, uph
00f06e cf95          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
00f06f ff07          .dw $ff07
00f070 7628
00f071 6c61
00f072 6575
00f073 0029          .db "(value)", 0
00f074 f024          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
00f075 f076          .dw PFA_DOVALUE
                 PFA_DOVALUE:
00f076 940e 0e5b     call_ DO_DODOES
00f078 f0ba          .dw XT_DUP
00f079 f3d7          .dw XT_FETCHI
00f07a f0cd          .dw XT_SWAP
00f07b f244          .dw XT_1PLUS
00f07c f3d7          .dw XT_FETCHI
00f07d f02a          .dw XT_EXECUTE
00f07e f020          .dw XT_EXIT
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
00f07f ff01          .dw $ff01
00f080 0040          .db "@",0
00f081 f06f          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
00f082 f083          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
00f083 01fc          movw zl, tosl
                     ; low byte is read before the high byte
00f084 9181          ld tosl, z+
00f085 9191          ld tosh, z+
00f086 cf7d          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
00f087 ff01          .dw $ff01
00f088 0021          .db "!",0
00f089 f07f          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00f08a f08b          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00f08b 01fc          movw zl, tosl
00f08c 9189
00f08d 9199          loadtos
                     ; the high byte is written before the low byte
00f08e 8391          std Z+1, tosh
00f08f 8380          std Z+0, tosl
00f090 9189
00f091 9199          loadtos
00f092 cf71          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
00f093 ff02          .dw $ff02
00f094 2163          .db "c!"
00f095 f087          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
00f096 f097          .dw PFA_CSTORE
                 PFA_CSTORE:
00f097 01fc          movw zl, tosl
00f098 9189
00f099 9199          loadtos
00f09a 8380          st Z, tosl
00f09b 9189
00f09c 9199          loadtos
00f09d cf66          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
00f09e ff02          .dw $ff02
00f09f 4063          .db "c@"
00f0a0 f093          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
00f0a1 f0a2          .dw PFA_CFETCH
                 PFA_CFETCH:
00f0a2 01fc          movw zl, tosl
00f0a3 2799          clr tosh
00f0a4 8180          ld tosl, Z
00f0a5 cf5e          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCHU:
00f0a6 ff02          .dw $ff02
00f0a7 7540          .db "@u"
00f0a8 f09e          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00f0a9 f000          .dw DO_COLON
                 PFA_FETCHU:
00f0aa f329          .dw XT_UP_FETCH
00f0ab f1b2          .dw XT_PLUS
00f0ac f082          .dw XT_FETCH
00f0ad f020          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STOREU:
00f0ae ff02          .dw $ff02
00f0af 7521          .db "!u"
00f0b0 f0a6          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
00f0b1 f000          .dw DO_COLON
                 PFA_STOREU:
00f0b2 f329          .dw XT_UP_FETCH
00f0b3 f1b2          .dw XT_PLUS
00f0b4 f08a          .dw XT_STORE
00f0b5 f020          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
00f0b6 ff03          .dw $ff03
00f0b7 7564
00f0b8 0070          .db "dup",0
00f0b9 f0ae          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
00f0ba f0bb          .dw PFA_DUP
                 PFA_DUP:
00f0bb 939a
00f0bc 938a          savetos
00f0bd cf46          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
00f0be ff04          .dw $ff04
00f0bf 643f
00f0c0 7075          .db "?dup"
00f0c1 f0b6          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
00f0c2 f0c3          .dw PFA_QDUP
                 PFA_QDUP:
00f0c3 2f08          mov temp0, tosl
00f0c4 2b09          or temp0, tosh
00f0c5 f011          breq PFA_QDUP1
00f0c6 939a
00f0c7 938a          savetos
                 PFA_QDUP1:
00f0c8 cf3b          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
00f0c9 ff04          .dw $ff04
00f0ca 7773
00f0cb 7061          .db "swap"
00f0cc f0be          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
00f0cd f0ce          .dw PFA_SWAP
                 PFA_SWAP:
00f0ce 018c          movw temp0, tosl
00f0cf 9189
00f0d0 9199          loadtos
00f0d1 931a          st -Y, temp1
00f0d2 930a          st -Y, temp0
00f0d3 cf30          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
00f0d4 ff04          .dw $ff04
00f0d5 766f
00f0d6 7265          .db "over"
00f0d7 f0c9          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
00f0d8 f0d9          .dw PFA_OVER
                 PFA_OVER:
00f0d9 939a
00f0da 938a          savetos
00f0db 818a          ldd tosl, Y+2
00f0dc 819b          ldd tosh, Y+3
                 
00f0dd cf26          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
00f0de ff04          .dw $ff04
00f0df 7264
00f0e0 706f          .db "drop"
00f0e1 f0d4          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
00f0e2 f0e3          .dw PFA_DROP
                 PFA_DROP:
00f0e3 9189
00f0e4 9199          loadtos
00f0e5 cf1e          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
00f0e6 ff03          .dw $ff03
00f0e7 6f72
00f0e8 0074          .db "rot",0
00f0e9 f0de          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
00f0ea f0eb          .dw PFA_ROT
                 PFA_ROT:
00f0eb 018c          movw temp0, tosl
00f0ec 9129          ld temp2, Y+
00f0ed 9139          ld temp3, Y+ 
00f0ee 9189
00f0ef 9199          loadtos
                         
00f0f0 933a          st -Y, temp3
00f0f1 932a          st -Y, temp2
00f0f2 931a          st -Y, temp1
00f0f3 930a          st -Y, temp0
                 
00f0f4 cf0f          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
00f0f5 ff02          .dw $ff02
00f0f6 3e72          .db "r>"
00f0f7 f0e6          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
00f0f8 f0f9          .dw PFA_R_FROM
                 PFA_R_FROM:
00f0f9 939a
00f0fa 938a          savetos
00f0fb 918f          pop tosl
00f0fc 919f          pop tosh
00f0fd cf06          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
00f0fe ff02          .dw $ff02
00f0ff 723e          .db ">r"
00f100 f0f5          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
00f101 f102          .dw PFA_TO_R
                 PFA_TO_R:
00f102 939f          push tosh
00f103 938f          push tosl
00f104 9189
00f105 9199          loadtos
00f106 cefd          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
00f107 ff02          .dw $ff02
00f108 4072          .db "r@"
00f109 f0fe          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
00f10a f10b          .dw PFA_R_FETCH
                 PFA_R_FETCH:
00f10b 939a
00f10c 938a          savetos
00f10d 918f          pop tosl
00f10e 919f          pop tosh
00f10f 939f          push tosh
00f110 938f          push tosl
00f111 cef2          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/notequal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 VE_NOTEQUAL:
00f112 ff02          .dw $ff02
00f113 3e3c          .db "<>"
00f114 f107          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
00f115 f116          .dw PFA_NOTEQUAL
                 PFA_NOTEQUAL:
00f116 9129          ld temp2, Y+
00f117 9139          ld temp3, Y+
00f118 1782          cp tosl, temp2
00f119 0793          cpc tosh, temp3
00f11a f199          breq PFA_ZERO1
00f11b c03b          rjmp PFA_TRUE1
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
00f11c ff01          .dw $ff01
00f11d 003d          .db "=",0
00f11e f112          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
00f11f f120          .dw PFA_EQUAL
                 PFA_EQUAL:
00f120 9129          ld temp2, Y+
00f121 9139          ld temp3, Y+
00f122 1782          cp tosl, temp2
00f123 0793          cpc tosh, temp3
                 PFA_EQUALDONE:
00f124 f549          brne PFA_ZERO1
00f125 c031          rjmp PFA_TRUE1
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_EQUALZERO:
00f126 ff02          .dw $ff02
00f127 3d30          .db "0="
00f128 f11c          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUALZERO
                 XT_EQUALZERO:
00f129 f12a          .dw PFA_EQUALZERO
                 PFA_EQUALZERO:
00f12a 2b98          or tosh, tosl
00f12b cff8          rjmp PFA_EQUALDONE
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
00f12c ff01          .dw $ff01
00f12d 003c          .db "<",0
00f12e f126          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
00f12f f130          .dw PFA_LESS
                 PFA_LESS:
00f130 9129          ld temp2, Y+
00f131 9139          ld temp3, Y+
00f132 1728          cp temp2, tosl
00f133 0739          cpc temp3, tosh
                 PFA_LESSDONE:
00f134 f4cc          brge PFA_ZERO1
00f135 c021          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
00f136 ff01          .dw $ff01
00f137 003e          .db ">",0
00f138 f12c          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
00f139 f13a          .dw PFA_GREATER
                 PFA_GREATER:
00f13a 9129          ld temp2, Y+
00f13b 9139          ld temp3, Y+
00f13c 1728          cp temp2, tosl
00f13d 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
00f13e f07c          brlt PFA_ZERO1
00f13f f071          brbs 1, PFA_ZERO1
00f140 c016          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_LESSZERO:
00f141 ff02          .dw $ff02
00f142 3c30          .db "0<"
00f143 f136          .dw VE_HEAD
                     .set VE_HEAD = VE_LESSZERO
                 XT_LESSZERO:
00f144 f145          .dw PFA_LESSZERO
                 PFA_LESSZERO:
00f145 1582          cp tosl, zerol
00f146 0593          cpc tosh, zeroh
00f147 cfec          rjmp PFA_LESSDONE
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
00f148 ff01          .dw $ff01
00f149 0030          .db "0",0
00f14a f141          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
00f14b f14c          .dw PFA_ZERO
                 PFA_ZERO:
00f14c 939a
00f14d 938a          savetos
                 PFA_ZERO1:
00f14e 01c1          movw tosl, zerol
00f14f ceb4          jmp_ DO_NEXT
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
00f150 ff04          .dw $ff04
00f151 7274
00f152 6575          .db "true"
00f153 f148          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
00f154 f155          .dw PFA_TRUE
                 PFA_TRUE:
00f155 939a
00f156 938a          savetos
                 PFA_TRUE1:
00f157 ef8f          ser tosl
00f158 ef9f          ser tosh
00f159 ceaa          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
00f15a ff02          .dw $ff02
00f15b 3c75          .db "u<"
00f15c f150          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
00f15d f15e          .dw PFA_ULESS
                 PFA_ULESS:
00f15e 9129          ld temp2, Y+
00f15f 9139          ld temp3, Y+
00f160 1782          cp tosl, temp2
00f161 0793          cpc tosh, temp3
00f162 f358          brlo PFA_ZERO1
00f163 f351          brbs 1, PFA_ZERO1
00f164 cff2          jmp_ PFA_TRUE1
                 .include "words/ugreater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 VE_UGREATER:
00f165 ff02          .dw $ff02
00f166 3e75          .db "u>"
00f167 f15a          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
00f168 f169          .dw PFA_UGREATER
                 PFA_UGREATER:
00f169 9129          ld temp2, Y+
00f16a 9139          ld temp3, Y+
00f16b 1728          cp temp2, tosl
00f16c 0739          cpc temp3, tosh
00f16d f300          brlo PFA_ZERO1
00f16e f2f9          brbs 1, PFA_ZERO1
00f16f cfe7          rjmp PFA_TRUE1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
00f170 ff02          .dw $ff02
00f171 3e30          .db "0>"
00f172 f165          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
00f173 f174          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
00f174 1582          cp tosl, zerol
00f175 0593          cpc tosh, zeroh
00f176 cfc7          rjmp PFA_GREATERDONE
                 .include "words/d-greater.asm"
                 
                 ; Compare
                 ; compares two double cell values (signed)
                 VE_DGREATER:
00f177 ff02          .dw $ff02
00f178 3e64          .db "d>"
00f179 f170          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATER
                 XT_DGREATER:
00f17a f17b          .dw PFA_DGREATER
                 PFA_DGREATER:
00f17b 9109          ld temp0, Y+
00f17c 9119          ld temp1, Y+
                 
00f17d 9129          ld temp2, Y+
00f17e 9139          ld temp3, Y+
00f17f 90e9          ld temp4, Y+
00f180 90f9          ld temp5, Y+
                 
00f181 16e0          cp temp4, temp0
00f182 06f1          cpc temp5, temp1
00f183 0728          cpc temp2, tosl
00f184 0739          cpc temp3, tosh
00f185 cfb8          jmp_ PFA_GREATERDONE
                 .include "words/d-less.asm"
                 
                 ; Compare
                 ; checks whether d1 is less than d2
                 VE_DLESS:
00f186 ff02          .dw $ff02
00f187 3c64          .db "d<"
00f188 f177          .dw VE_HEAD
                     .set VE_HEAD = VE_DLESS
                 XT_DLESS:
00f189 f18a          .dw PFA_DLESS
                 PFA_DLESS:
00f18a 9109          ld temp0, Y+
00f18b 9119          ld temp1, Y+
                 
00f18c 9129          ld temp2, Y+
00f18d 9139          ld temp3, Y+
00f18e 90e9          ld temp4, Y+
00f18f 90f9          ld temp5, Y+
00f190 16e0          cp temp4, temp0
00f191 06f1          cpc temp5, temp1
00f192 0728          cpc temp2, tosl
00f193 0739          cpc temp3, tosh
00f194 cf9f          jmp_ PFA_LESSDONE
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
00f195 ff04          .dw $ff04
00f196 6f6c
00f197 3267          .db "log2"
00f198 f186          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
00f199 f19a          .dw PFA_LOG2
                 PFA_LOG2:
00f19a 01fc          movw zl, tosl
00f19b 2799          clr tosh
00f19c e180          ldi tosl, 16
                 PFA_LOG2_1:
00f19d 958a          dec tosl
00f19e f022          brmi PFA_LOG2_2 ; wrong data
00f19f 0fee          lsl  zl
00f1a0 1fff          rol  zh
00f1a1 f7d8          brcc PFA_LOG2_1
00f1a2 ce61          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
00f1a3 959a          dec tosh
00f1a4 ce5f          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
00f1a5 ff01          .dw $ff01
00f1a6 002d          .db "-",0
00f1a7 f195          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
00f1a8 f1a9          .dw PFA_MINUS
                 PFA_MINUS:
00f1a9 9109          ld temp0, Y+
00f1aa 9119          ld temp1, Y+
00f1ab 1b08          sub temp0, tosl
00f1ac 0b19          sbc temp1, tosh
00f1ad 01c8          movw tosl, temp0
00f1ae ce55          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
00f1af ff01          .dw $ff01
00f1b0 002b          .db "+",0
00f1b1 f1a5          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
00f1b2 f1b3          .dw PFA_PLUS
                 PFA_PLUS:
00f1b3 9109          ld temp0, Y+
00f1b4 9119          ld temp1, Y+
00f1b5 0f80          add tosl, temp0
00f1b6 1f91          adc tosh, temp1
00f1b7 ce4c          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
00f1b8 ff02          .dw $ff02
00f1b9 2a6d          .db "m*"
00f1ba f1af          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
00f1bb f1bc          .dw PFA_MSTAR
                 PFA_MSTAR:
00f1bc 018c          movw temp0, tosl
00f1bd 9189
00f1be 9199          loadtos
00f1bf 019c          movw temp2, tosl
                     ; high cell ah*bh
00f1c0 0231          muls temp3, temp1
00f1c1 0170          movw temp4, r0
                     ; low cell  al*bl
00f1c2 9f20          mul  temp2, temp0
00f1c3 01c0          movw tosl, r0
                     ; signed ah*bl
00f1c4 0330          mulsu temp3, temp0
00f1c5 08f3          sbc   temp5, zeroh
00f1c6 0d90          add   tosh,  r0
00f1c7 1ce1          adc   temp4, r1
00f1c8 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
00f1c9 0312          mulsu temp1, temp2
00f1ca 08f3          sbc   temp5, zeroh
00f1cb 0d90          add   tosh,  r0
00f1cc 1ce1          adc   temp4, r1
00f1cd 1cf3          adc   temp5, zeroh
                 
00f1ce 939a
00f1cf 938a          savetos
00f1d0 01c7          movw tosl, temp4
00f1d1 ce32          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
00f1d2 ff06          .dw $ff06
00f1d3 6d75
00f1d4 6d2f
00f1d5 646f          .db "um/mod"
00f1d6 f1b8          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
00f1d7 f1d8          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
00f1d8 017c          movw temp4, tosl
                 
00f1d9 9129          ld temp2, Y+
00f1da 9139          ld temp3, Y+
                   
00f1db 9109          ld temp0, Y+
00f1dc 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
00f1dd e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
00f1de 2755          clr temp7
00f1df 0f00          lsl temp0
00f1e0 1f11          rol temp1
00f1e1 1f22          rol temp2
00f1e2 1f33          rol temp3
00f1e3 1f55          rol temp7
                 
                   ; try subtracting divisor
00f1e4 152e          cp temp2, temp4
00f1e5 053f          cpc temp3, temp5
00f1e6 0552          cpc temp7,zerol
                 
00f1e7 f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
00f1e8 9503          inc temp0
00f1e9 192e          sub temp2, temp4
00f1ea 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
00f1eb 954a          dec  temp6
00f1ec f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
00f1ed 933a          st -Y,temp3
00f1ee 932a          st -Y,temp2
                 
                     ; put quotient on stack
00f1ef 01c8          movw tosl, temp0
00f1f0 ce13          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
00f1f1 ff03          .dw $ff03
00f1f2 6d75
00f1f3 002a          .db "um*",0
00f1f4 f1d2          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
00f1f5 f1f6          .dw PFA_UMSTAR
                 PFA_UMSTAR:
00f1f6 018c          movw temp0, tosl
00f1f7 9189
00f1f8 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
00f1f9 9f80          mul tosl,temp0
00f1fa 01f0          movw zl, r0
00f1fb 2722          clr temp2
00f1fc 2733          clr temp3
                     ; middle bytes
00f1fd 9f90          mul tosh, temp0
00f1fe 0df0          add zh, r0
00f1ff 1d21          adc temp2, r1
00f200 1d33          adc temp3, zeroh
                         
00f201 9f81          mul tosl, temp1
00f202 0df0          add zh, r0
00f203 1d21          adc temp2, r1
00f204 1d33          adc temp3, zeroh
                     
00f205 9f91          mul tosh, temp1
00f206 0d20          add temp2, r0
00f207 1d31          adc temp3, r1
00f208 01cf          movw tosl, zl
00f209 939a
00f20a 938a          savetos
00f20b 01c9          movw tosl, temp2
00f20c cdf7          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
00f20d ff06          .dw $ff06
00f20e 6e69
00f20f 6576
00f210 7472          .db "invert"
00f211 f1f1          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
00f212 f213          .dw PFA_INVERT
                 PFA_INVERT:
00f213 9580          com tosl
00f214 9590          com tosh
00f215 cdee          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
00f216 ff02          .dw $ff02
00f217 2f32          .db "2/"
00f218 f20d          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
00f219 f21a          .dw PFA_2SLASH
                 PFA_2SLASH:
00f21a 9595          asr tosh
00f21b 9587          ror tosl
00f21c cde7          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
00f21d ff02          .dw $ff02
00f21e 2a32          .db "2*"
00f21f f216          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
00f220 f221          .dw PFA_2STAR
                 PFA_2STAR:
00f221 0f88          lsl tosl
00f222 1f99          rol tosh
00f223 cde0          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
00f224 ff03          .dw $ff03
00f225 6e61
00f226 0064          .db "and",0
00f227 f21d          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
00f228 f229          .dw PFA_AND
                 PFA_AND:
00f229 9109          ld temp0, Y+
00f22a 9119          ld temp1, Y+
00f22b 2380          and tosl, temp0
00f22c 2391          and tosh, temp1
00f22d cdd6          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
00f22e ff02          .dw $ff02
00f22f 726f          .db "or"
00f230 f224          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
00f231 f232          .dw PFA_OR
                 PFA_OR:
00f232 9109          ld temp0, Y+
00f233 9119          ld temp1, Y+
00f234 2b80          or tosl, temp0
00f235 2b91          or tosh, temp1
00f236 cdcd          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
00f237 ff03          .dw $ff03
00f238 6f78
00f239 0072          .db "xor",0
00f23a f22e          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
00f23b f23c          .dw PFA_XOR
                 PFA_XOR:
00f23c 9109          ld temp0, Y+
00f23d 9119          ld temp1, Y+
00f23e 2780          eor tosl, temp0
00f23f 2791          eor tosh, temp1
00f240 cdc3          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
00f241 ff02          .dw $ff02
00f242 2b31          .db "1+"
00f243 f237          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
00f244 f245          .dw PFA_1PLUS
                 PFA_1PLUS:
00f245 9601          adiw tosl,1
00f246 cdbd          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
00f247 ff02          .dw $ff02 
00f248 2d31          .db "1-"
00f249 f241          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
00f24a f24b          .dw PFA_1MINUS
                 PFA_1MINUS:
00f24b 9701          sbiw tosl, 1
00f24c cdb7          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
00f24d ff06          .dw $ff06
00f24e 736c
00f24f 6968
00f250 7466          .db "lshift"
00f251 f247          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
00f252 f253          .dw PFA_LSHIFT
                 PFA_LSHIFT:
00f253 01fc          movw zl, tosl
00f254 9189
00f255 9199          loadtos
                 PFA_LSHIFT1:
00f256 9731          sbiw zl, 1
00f257 f01a          brmi PFA_LSHIFT2
00f258 0f88          lsl tosl
00f259 1f99          rol tosh
00f25a cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
00f25b cda8          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
00f25c ff06          .dw $ff06
00f25d 7372
00f25e 6968
00f25f 7466          .db "rshift"
00f260 f24d          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
00f261 f262          .dw PFA_RSHIFT
                 PFA_RSHIFT:
00f262 01fc          movw zl, tosl
00f263 9189
00f264 9199          loadtos
                 PFA_RSHIFT1:
00f265 9731          sbiw zl, 1
00f266 f01a          brmi PFA_RSHIFT2
00f267 9596          lsr tosh
00f268 9587          ror tosl
00f269 cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
00f26a cd99          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
00f26b ff02          .dw $ff02
00f26c 212b          .db "+!"
00f26d f25c          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
00f26e f26f          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
00f26f 01fc          movw zl, tosl
00f270 9189
00f271 9199          loadtos
00f272 8120          ldd temp2, Z+0
00f273 8131          ldd temp3, Z+1
00f274 0f82          add tosl, temp2
00f275 1f93          adc tosh, temp3
00f276 8380          std Z+0, tosl
00f277 8391          std Z+1, tosh
00f278 9189
00f279 9199          loadtos
00f27a cd89          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
00f27b ff03          .dw $ff03
00f27c 7072
00f27d 0040          .db "rp@",0
00f27e f26b          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
00f27f f280          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
00f280 939a
00f281 938a          savetos
00f282 b78d          in tosl, SPL
00f283 b79e          in tosh, SPH
00f284 cd7f          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
00f285 ff03          .dw $ff03
00f286 7072
00f287 0021          .db "rp!",0
00f288 f27b          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
00f289 f28a          .dw PFA_RP_STORE
                 PFA_RP_STORE:
00f28a b72f          in temp2, SREG
00f28b 94f8          cli
00f28c bf8d          out SPL, tosl
00f28d bf9e          out SPH, tosh
00f28e bf2f          out SREG, temp2
00f28f 9189
00f290 9199          loadtos
00f291 cd72          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
00f292 ff03          .dw $ff03
00f293 7073
00f294 0040          .db "sp@",0
00f295 f285          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
00f296 f297          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
00f297 939a
00f298 938a          savetos
00f299 01ce          movw tosl, yl
00f29a cd69          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
00f29b ff03          .dw $ff03
00f29c 7073
00f29d 0021          .db "sp!",0
00f29e f292          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
00f29f f2a0          .dw PFA_SP_STORE
                 PFA_SP_STORE:
00f2a0 01ec          movw yl, tosl
00f2a1 9189
00f2a2 9199          loadtos
00f2a3 cd60          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
00f2a4 f2a5          .dw PFA_DODO
                 PFA_DODO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
00f2a5 01fd          movw zl, xl
00f2a6 2755
00f2a7 0fee
00f2a8 1fff
00f2a9 1f55
00f2aa bf5b
00f2ab 9107
00f2ac 9117          readflashcell temp0,temp1
00f2ad 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
00f2ae 9129          ld temp2, Y+
00f2af 9139          ld temp3, Y+
                 PFA_DODO1:
00f2b0 931f          push temp1
00f2b1 930f          push temp0
00f2b2 933f          push temp3
00f2b3 932f          push temp2
00f2b4 939f          push tosh
00f2b5 938f          push tosl
00f2b6 9189
00f2b7 9199          loadtos
00f2b8 cd4b          jmp_ DO_NEXT
                 .include "words/doqdo.asm"
                 
                 ; System
                 ; runtime of ?do
                 ;VE_DOQDO:
                 ;    .dw $ff05
                 ;    .db "(?do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOQDO
                 XT_DOQDO:
00f2b9 f2ba          .dw PFA_DOQDO
                 PFA_DOQDO:
                     ; put the content of the next flash cell on return stack
                     ; it is the address of the instruction _after_ the (+)loop
00f2ba 01fd          movw zl, xl
00f2bb 2755
00f2bc 0fee
00f2bd 1fff
00f2be 1f55
00f2bf bf5b
00f2c0 9107
00f2c1 9117          readflashcell temp0,temp1
00f2c2 9611          adiw xl, 1    ; adjust to NEXT+1 = jump over <mark (for leave)
                 
00f2c3 9129          ld temp2, Y+
00f2c4 9139          ld temp3, Y+
                     ; now check for equality
00f2c5 1782          cp tosl, temp2
00f2c6 0793          cpc tosh, temp3
00f2c7 f741          brne PFA_DODO1
                     ; both values are the same -> skip loop
00f2c8 01d8          movw xl, temp0
00f2c9 9189
00f2ca 9199          loadtos
00f2cb cd38          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
00f2cc ff01          .dw $FF01
00f2cd 0069          .db "i",0
00f2ce f29b          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
00f2cf f10b          .dw PFA_R_FETCH
                 
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
00f2d0 f2d1          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
00f2d1 91ef          pop zl
00f2d2 91ff          pop zh
00f2d3 0fe8          add zl, tosl
00f2d4 1ff9          adc zh, tosh
00f2d5 2f19          mov temp1, tosh
00f2d6 9189
00f2d7 9199          loadtos
                 PFA_DOPLUSLOOP4: 
00f2d8 912f          pop temp2
00f2d9 913f          pop temp3
00f2da 17e2          cp zl, temp2
00f2db 07f3          cpc zh, temp3
00f2dc ff17          sbrs temp1, 7 ; if msb is set, increment is negative. in that case skip the next instruction
00f2dd c002          rjmp PFA_DOPLUSLOOP2 ; jump to test for positive overflow
00f2de f03c          brlt PFA_DOPLUSLOOP1 ; exit if underflow
00f2df c001          rjmp PFA_DOPLUSLOOP3
                 PFA_DOPLUSLOOP2:
00f2e0 f42c          brge PFA_DOPLUSLOOP1 ; exit if overflow
                 PFA_DOPLUSLOOP3:
                     ; next iteration
00f2e1 933f          push temp3
00f2e2 932f          push temp2
00f2e3 93ff          push zh
00f2e4 93ef          push zl
00f2e5 cd4a          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP1: 
00f2e6 910f          pop  temp0
00f2e7 911f          pop  temp1  ; remove leave destination
00f2e8 9611          adiw xl, 1 ; skip branch-back address
00f2e9 cd1a          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
00f2ea f2eb          .dw PFA_DOLOOP
                 PFA_DOLOOP:
00f2eb 91ef          pop zl
00f2ec 91ff          pop zh
00f2ed 9631          adiw zl,1
00f2ee 912f          pop temp2
00f2ef 913f          pop temp3
00f2f0 17e2          cp zl, temp2
00f2f1 07f3          cpc zh, temp3
00f2f2 f399          breq PFA_DOPLUSLOOP1
00f2f3 cfed          jmp_ PFA_DOPLUSLOOP3
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
00f2f4 ff06          .dw $ff06
00f2f5 6e75
00f2f6 6f6c
00f2f7 706f          .db "unloop"
00f2f8 f2cc          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
00f2f9 f2fa          .dw PFA_UNLOOP
                 PFA_UNLOOP:
00f2fa 911f          pop temp1
00f2fb 910f          pop temp0
00f2fc 911f          pop temp1
00f2fd 910f          pop temp0
00f2fe 911f          pop temp1
00f2ff 910f          pop temp0
00f300 cd03          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
00f301 ff06          .dw $ff06
00f302 6d63
00f303 766f
00f304 3e65          .db "cmove>"
00f305 f2f4          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
00f306 f307          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
00f307 93bf          push xh
00f308 93af          push xl
00f309 91e9          ld zl, Y+
00f30a 91f9          ld zh, Y+ ; addr-to
00f30b 91a9          ld xl, Y+
00f30c 91b9          ld xh, Y+ ; addr-from
00f30d 2f09          mov temp0, tosh
00f30e 2b08          or temp0, tosl
00f30f f041          brbs 1, PFA_CMOVE_G1
00f310 0fe8          add zl, tosl
00f311 1ff9          adc zh, tosh
00f312 0fa8          add xl, tosl
00f313 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
00f314 911e          ld temp1, -X
00f315 9312          st -Z, temp1
00f316 9701          sbiw tosl, 1
00f317 f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
00f318 91af          pop xl
00f319 91bf          pop xh
00f31a 9189
00f31b 9199          loadtos
00f31c cce7          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
00f31d ff02          .dw $ff02
00f31e 3c3e          .db "><"
00f31f f301          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
00f320 f321          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
00f321 2f09          mov temp0, tosh
00f322 2f98          mov tosh, tosl
00f323 2f80          mov tosl, temp0
00f324 ccdf          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
00f325 ff03          .dw $ff03
00f326 7075
00f327 0040          .db "up@",0
00f328 f31d          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
00f329 f32a          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
00f32a 939a
00f32b 938a          savetos
00f32c 01c2          movw tosl, upl
00f32d ccd6          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
00f32e ff03          .dw $ff03
00f32f 7075
00f330 0021          .db "up!",0
00f331 f325          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
00f332 f333          .dw PFA_UP_STORE
                 PFA_UP_STORE:
00f333 012c          movw upl, tosl
00f334 9189
00f335 9199          loadtos
00f336 cccd          jmp_ DO_NEXT
                 .include "words/s_to_d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 VE_S2D:
00f337 ff03          .dw $ff03
00f338 3e73
00f339 0064          .db "s>d",0
00f33a f32e          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
00f33b f000          .dw DO_COLON
                 PFA_S2D:
00f33c f0ba          .dw XT_DUP
00f33d f144          .dw XT_LESSZERO
                 .include "words/not.asm"
00f33e f020      
                 ; Logic
                 ; identical to 0=
                 VE_NOT:
00f33f ff03          .dw $ff03
00f340 6f6e
00f341 0074          .db "not",0
00f342 f337          .dw VE_HEAD
                     .set VE_HEAD = VE_NOT
                 XT_NOT:
00f343 f000          .dw DO_COLON
                 PFA_NOT:
00f344 f129          .dw XT_EQUALZERO
00f345 f020          .dw XT_EXIT
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
00f346 ff02          .dw $ff02
00f347 6521          .db "!e"
00f348 f33f          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
00f349 f34a          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
00f34a 01fc          movw zl, tosl
00f34b 9189
00f34c 9199          loadtos
00f34d b72f          in_ temp2, SREG
00f34e 94f8          cli
00f34f d007          rcall PFA_STOREE1
00f350 9631          adiw zl,1
                 
00f351 2f89          mov tosl, tosh
00f352 d004          rcall PFA_STOREE1
00f353 bf2f          out_ SREG, temp2
00f354 9189
00f355 9199          loadtos
00f356 ccad          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
00f357 99f9          sbic EECR, EEPE
00f358 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
00f359 b707          in_ temp0, SPMCSR
00f35a fd00          sbrc temp0,SPMEN
00f35b cffd          rjmp PFA_STOREE2
                 
00f35c bdf2          out_ EEARH,zh
00f35d bde1          out_ EEARL,zl
00f35e bd80          out_ EEDR, tosl
00f35f 9afa          sbi EECR,EEMPE
00f360 9af9          sbi EECR,EEPE
                 
00f361 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
00f362 ff02          .dw $ff02
00f363 6540          .db "@e"
00f364 f346          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
00f365 f366          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
00f366 b72f          in_ temp2, SREG
00f367 94f8          cli
00f368 01fc          movw zl, tosl
00f369 d006          rcall PFA_FETCHE2
00f36a b580          in_ tosl, EEDR
                 
00f36b 9631          adiw zl,1
                 
00f36c d003          rcall PFA_FETCHE2
00f36d b590          in_  tosh, EEDR
00f36e bf2f          out_ SREG, temp2
00f36f cc94          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
00f370 99f9          sbic EECR, EEPE
00f371 cffe          rjmp PFA_FETCHE2
                 
00f372 bdf2          out_ EEARH,zh
00f373 bde1          out_ EEARL,zl
                 
00f374 9af8          sbi EECR,EERE
00f375 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 
                 .include "words/store-i.asm"
                 
                 ; Memory
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
00f376 ff02          .dw $ff02
00f377 6921          .db "!i"
00f378 f362          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
00f379 089d          .dw PFA_DODEFER
                 PFA_STOREI:
00f37a 000a          .dw EE_STOREI
00f37b 0861          .dw XT_EDEFERFETCH
00f37c 0866          .dw XT_EDEFERSTORE
                 .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
00f37d ff09          .dw $ff09
00f37e 2128
00f37f 2d69
00f380 726e
00f381 7777
00f382 0029          .db "(!i-nrww)",0
00f383 f376          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
00f384 f385          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
00f385 b71f        in temp1,SREG
00f386 931f        push temp1
00f387 94f8        cli
                 
00f388 019c        movw temp2, tosl ; save the (word) address
00f389 9189
00f38a 9199        loadtos          ; get the new value for the flash cell
00f38b 93af        push xl
00f38c 93bf        push xh
00f38d 93cf        push yl
00f38e 93df        push yh
00f38f d009        rcall DO_STOREI_atmega
00f390 91df        pop yh
00f391 91cf        pop yl
00f392 91bf        pop xh
00f393 91af        pop xl
                   ; finally clear the stack
00f394 9189
00f395 9199        loadtos
00f396 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
00f397 bf1f        out SREG,temp1
                 
00f398 cc6b        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
00f399 d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
00f39a 94e0        com temp4
00f39b 94f0        com temp5
00f39c 218e        and tosl, temp4
00f39d 219f        and tosh, temp5
00f39e 2b98        or tosh, tosl
00f39f f019        breq DO_STOREI_writepage 
                 
00f3a0 01f9          movw zl, temp2
00f3a1 e002          ldi temp0,(1<<PGERS)
00f3a2 d023          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
00f3a3 01f9        movw zl, temp2
00f3a4 e004        ldi temp0,(1<<PGWRT)
00f3a5 d020        rcall dospm
                 
                   ; reenable RWW section
00f3a6 01f9        movw zl, temp2
00f3a7 e100        ldi temp0,(1<<RWWSRE)
00f3a8 d01d        rcall dospm
00f3a9 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
00f3aa 01f9        movw zl, temp2
                   ; get the beginning of page
00f3ab 78e0        andi zl,low(pagemask)
00f3ac 7fff        andi zh,high(pagemask)
00f3ad 01ef        movw y, z
                   ; loop counter (in words)
00f3ae e8a0        ldi xl,low(pagesize)
00f3af e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
00f3b0 01fe        movw z, y
00f3b1 2755
00f3b2 0fee
00f3b3 1fff
00f3b4 1f55
00f3b5 bf5b
00f3b6 9147
00f3b7 9157        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
00f3b8 01fe        movw z, y
00f3b9 17e2        cp zl, temp2
00f3ba 07f3        cpc zh, temp3
00f3bb f011        breq pageload_newdata
00f3bc 010a          movw r0, temp6
00f3bd c002          rjmp pageload_cont
                 pageload_newdata:
00f3be 017a          movw temp4, temp6
00f3bf 010c          movw r0, tosl
                 pageload_cont:
00f3c0 2700        clr temp0
00f3c1 d004        rcall dospm
00f3c2 9621        adiw y, 1
00f3c3 9711        sbiw x, 1
00f3c4 f759        brne pageload_loop
                 
                 pageload_done:
00f3c5 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
00f3c6 99f9        sbic EECR, EEPE
00f3c7 cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
00f3c8 b717        in_  temp1, SPMCSR
00f3c9 fd10        sbrc temp1, SPMEN
00f3ca cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
00f3cb 2755
00f3cc 0fee
00f3cd 1fff
00f3ce 1f55
00f3cf bf5b        writeflashcell
                   ; execute spm
00f3d0 6001        ori temp0, (1<<SPMEN)
00f3d1 bf07        out_ SPMCSR,temp0
00f3d2 95e8        spm
00f3d3 9508        ret
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
00f3d4 ff02          .dw $ff02
00f3d5 6940          .db "@i"
00f3d6 f37d          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
00f3d7 f3d8          .dw PFA_FETCHI
                 PFA_FETCHI:
00f3d8 01fc          movw zl, tosl
00f3d9 2755
00f3da 0fee
00f3db 1fff
00f3dc 1f55
00f3dd bf5b
00f3de 9187
00f3df 9197          readflashcell tosl,tosh
00f3e0 cc23          jmp_ DO_NEXT
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000000 ff ff     
                 EE_DP:
000002 0c 11         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
000004 1f 03         .dw HERESTART    ; Memory Allocation
                 EE_EDP:
000006 54 00         .dw EDPSTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
000008 6b 10         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
00000a 84 f3         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
00000c 2f 00         .dw UBRR_VAL     ; BAUDRATE
                 EE_ENVIRONMENT:
00000e 7a 0f         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
000010 14 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
000012 14 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
000014 d4 f3         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 EE_ORDERLISTLEN:
000016 01 00         .dw 1
                 EE_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000018 14 00         .dw EE_FORTHWORDLIST      ; get/set-order
00001a               .byte  (NUMWORDLISTS-1)*CELLSIZE ; two slots are already used
                 
                 ; default user area
                 EE_INITUSER:
000028 00 00         .dw 0  ; USER_STATE
00002a 00 00         .dw 0  ; USER_FOLLOWER
00002c ff 21         .dw rstackstart  ; USER_RP
00002e af 21         .dw stackstart   ; USER_SP0
000030 af 21         .dw stackstart   ; USER_SP
                     
000032 00 00         .dw 0  ; USER_HANDLER
000034 0a 00         .dw 10 ; USER_BASE
                     
000036 ca 00         .dw XT_TX  ; USER_EMIT
000038 d8 00         .dw XT_TXQ ; USER_EMITQ
00003a a0 00         .dw XT_RX  ; USER_KEY
00003c ba 00         .dw XT_RXQ ; USER_KEYQ
00003e aa 09         .dw XT_SOURCETIB ; USER_SKEY
000040 00 00         .dw 0            ; USER_G_IN
000042 96 09         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 
                 EE_RECOGNIZERS:
                 EE_RECOGNIZERLISTLEN:
000044 03 00         .dw 3
                 EE_RECOGNIZERLIST:
000046 cf 07         .dw XT_REC_FIND
000048 b2 07         .dw XT_REC_INTNUMBER
00004a eb 07         .dw XT_REC_NOTFOUND
00004c ff ff         .dw -1
00004e ff ff         .dw -1
000050 ff ff         .dw -1
                 
                 EE_WLSCOPE:
000052 b9 0f         .dw XT_GET_CURRENT  ; default wordlist scope
                 ; 1st free address in EEPROM.
                 EDPSTART:
                 .cseg
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega1281" register use summary:
r0 :  20 r1 :   5 r2 :   6 r3 :  11 r4 :   4 r5 :   1 r6 :  14 r7 :   0 
r8 :  14 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  28 r15:  26 
r16: 108 r17:  65 r18:  72 r19:  54 r20:  15 r21:  52 r22:  11 r23:   3 
r24: 264 r25: 195 r26:  48 r27:  22 r28:   8 r29:   4 r30: 122 r31:  53 
x  :   4 y  : 282 z  :  96 
Registers used: 31 out of 35 (88.6%)

"ATmega1281" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  26 add   :  19 adiw  :  19 and   :   5 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   6 
brcc  :   3 brcs  :   1 break :   0 breq  :   7 brge  :   2 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   2 brlt  :   2 brmi  :   3 
brne  :  25 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   2 cbi   :  10 cbr   :   1 
clc   :   3 clh   :   0 cli   :   6 cln   :   0 clr   :  28 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  15 cp    :  17 cpc   :  23 
cpi   :   0 cpse  :   0 dec   :  14 elpm  :  24 eor   :   4 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :  19 inc   :   2 
jmp   :  60 ld    : 215 ldd   :   5 ldi   :  48 lds   :   2 lpm   :   0 
lsl   :  19 lsr   :   1 mov   :  16 movw  : 102 mul   :   5 muls  :   1 
mulsu :   2 neg   :   0 nop   :   3 or    :  10 ori   :   2 out   :  34 
pop   :  57 push  :  43 rcall :  72 ret   :   8 reti  :   2 rjmp  :  96 
rol   :  41 ror   :   8 sbc   :   8 sbci  :   3 sbi   :  11 sbic  :   3 
sbis  :   0 sbiw  :  17 sbr   :   0 sbrc  :   3 sbrs  :   6 sec   :   2 
seh   :   0 sei   :   2 sen   :   0 ser   :   4 ses   :   0 set   :   2 
sev   :   0 sez   :   0 sleep :   0 spm   :   2 st    : 111 std   :   8 
sts   :   3 sub   :   5 subi  :   3 swap  :   0 tst   :   0 wdr   :   1 

Instructions used: 75 out of 114 (65.8%)

"ATmega1281" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x01e7c2   2820   9774  12594  131072   9.6%
[.dseg] 0x000200 0x00031f      0    287    287    8192   3.5%
[.eseg] 0x000000 0x000054      0     84     84    4096   2.1%

Assembly complete, 0 errors, 4 warnings
